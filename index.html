<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/IDECUBEKEIL/IDECUBEKEIL.github.io@main/img/web_logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="kiminocical"><meta property="og:url" content="https://idecubekeil.github.io/"><meta property="og:site_name" content="kiminocical"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/IDECUBEKEIL/IDECUBEKEIL.github.io@main/img/cloud.png"><meta property="article:author" content="IDECUBEKEIL"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/IDECUBEKEIL/IDECUBEKEIL.github.io@main/img/cloud.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":""}</script><link rel="icon" href="https://cdn.jsdelivr.net/gh/IDECUBEKEIL/IDECUBEKEIL.github.io@main/img/web_logo.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/IDECUBEKEIL/IDECUBEKEIL.github.io@main/img/logo.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/album">Album</a><a class="navbar-item" href="/friend">Friend</a><a class="navbar-item" href="/message">Message</a><a class="navbar-item" href="/self-talking">Self-talking</a><a class="navbar-item" href="/music">Music</a><a class="navbar-item" href="/media">Media</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-10-03  <span class="level-item"><i class="far fa-clock"> </i>24 m  <i class="fas fa-pencil-alt"> </i>3.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/10/03/Data%20Structure%20and%20Algorithms/">Leetcode学习</a></h1><div class="content"><p>欢迎来到我的cpp代码学习网站</p>
<blockquote>
<p>学习内容参考见 “代码随想录” <a target="_blank" rel="noopener" href="https://programmercarl.com/">https://programmercarl.com/</a></p>
</blockquote>
<h2 id="一、数据结构与算法"><a href="#一、数据结构与算法" class="headerlink" title="一、数据结构与算法"></a>一、数据结构与算法</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>常见三种结构</p>
<ul>
<li>数组</li>
<li>set</li>
<li>map<br>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可重复</th>
<th>能否改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值（或key）是否可重复</th>
<th>能否更改数值（或key）</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>
<h3 id="STL容器和容器适配器一些基本语法"><a href="#STL容器和容器适配器一些基本语法" class="headerlink" title="STL容器和容器适配器一些基本语法"></a>STL容器和容器适配器一些基本语法</h3><h4 id="表格1：非STL容器（STL容器适配器）"><a href="#表格1：非STL容器（STL容器适配器）" class="headerlink" title="表格1：非STL容器（STL容器适配器）"></a>表格1：非STL容器（STL容器适配器）</h4><table>
<thead>
<tr>
<th>具体容器</th>
<th>插入操作（函数+说明）</th>
<th>删除操作（函数+说明）</th>
<th>核心语法区别（易混点提醒）</th>
</tr>
</thead>
<tbody><tr>
<td>栈（stack）</td>
<td>push(val)：仅从「栈顶」插入（底层默认用deque实现，隐藏push_back，对外统一用push）</td>
<td>pop()：仅删除「栈顶」元素（无返回值，需用top()获取栈顶值后再删）</td>
<td>❌ 不支持push_back&#x2F;pop_back；仅支持栈顶操作（LIFO），无迭代器访问</td>
</tr>
<tr>
<td>队列（queue）</td>
<td>push(val)：仅从「队尾」插入（底层默认用deque实现，隐藏push_back，对外统一用push）</td>
<td>pop()：仅删除「队首」元素（无返回值，需用front()获取队首值后再删）</td>
<td>❌ 不支持push_back&#x2F;pop_front；仅支持队尾插、队首删（FIFO），无迭代器访问</td>
</tr>
<tr>
<td>优先级队列（priority_queue）</td>
<td>push(val)：插入元素后自动按优先级排序（底层用vector+堆实现，对外统一用push）</td>
<td>pop()：仅删除「优先级最高的元素」（堆顶，无返回值，需用top()获取后再删）</td>
<td>❌ 不支持push_back&#x2F;pop_back；无顺序概念，仅按优先级操作，无迭代器访问</td>
</tr>
</tbody></table>
<h4 id="表格2：STL容器（含关联-非关联区分）"><a href="#表格2：STL容器（含关联-非关联区分）" class="headerlink" title="表格2：STL容器（含关联&#x2F;非关联区分）"></a>表格2：STL容器（含关联&#x2F;非关联区分）</h4><table>
<thead>
<tr>
<th>具体容器</th>
<th>STL容器类型（关联&#x2F;非关联）</th>
<th>插入操作（函数+说明）</th>
<th>删除操作（函数+说明）</th>
<th>核心语法区别（易混点提醒）</th>
</tr>
</thead>
<tbody><tr>
<td>动态数组（vector）</td>
<td>非关联（序列容器）</td>
<td>1. push_back(val)：从「尾部」插入（唯一的push类接口，无push_front）<br>2. insert(iter, val)：在指定迭代器位置插入</td>
<td>1. pop_back()：删除「尾部」元素<br>2. erase(iter)：删除指定迭代器位置元素<br>3. erase(iter1, iter2)：删除区间元素</td>
<td>❌ 不支持push_front（头部插入效率极低）；仅尾部支持push_back&#x2F;pop_back，指定位置用insert&#x2F;erase</td>
</tr>
<tr>
<td>双向队列（deque）</td>
<td>非关联（序列容器）</td>
<td>1. push_back(val)：从「队尾」插入<br>2. push_front(val)：从「队首」插入</td>
<td>1. pop_back()：删除「队尾」元素<br>2. pop_front()：删除「队首」元素<br>3. erase(iter)：删除指定迭代器位置元素</td>
<td>✅ 同时支持push_back&#x2F;push_front（区别于vector）；可随机访问（用[]下标），适合两端频繁操作</td>
</tr>
<tr>
<td>集合（set）</td>
<td>关联（有序唯一集合）</td>
<td>insert(val)：按红黑树排序插入（无push&#x2F;push_back，因按「键」有序存储，非位置存储）</td>
<td>1. erase(key)：按元素值删除<br>2. erase(iter)：按迭代器删除<br>3. erase(iter1, iter2)：删除区间</td>
<td>❌ 完全不支持push&#x2F;push_back；元素有序且唯一，按值操作而非位置</td>
</tr>
<tr>
<td>多重集合（multiset）</td>
<td>关联（有序可重复集合）</td>
<td>insert(val)：按红黑树排序插入（无push&#x2F;push_back，支持重复值插入）</td>
<td>1. erase(key)：删除所有等于key的元素<br>2. erase(iter)：删除指定迭代器位置元素<br>3. erase(iter1, iter2)：删除区间</td>
<td>❌ 不支持push&#x2F;push_back；元素有序可重复，按值删除时需注意是否删除所有匹配项</td>
</tr>
<tr>
<td>映射（map）</td>
<td>关联（有序唯一键值对）</td>
<td>1. insert(pair&lt;key, val&gt;)：按key排序插入<br>2. map[key] &#x3D; val：直接赋值（不存在则插入，存在则修改）</td>
<td>1. erase(key)：按key删除<br>2. erase(iter)：按迭代器删除<br>3. erase(iter1, iter2)：删除区间</td>
<td>❌ 不支持push&#x2F;push_back；存储键值对（key唯一），[]操作符可插入&#x2F;修改值</td>
</tr>
<tr>
<td>多重映射（multimap）</td>
<td>关联（有序可重复键值对）</td>
<td>insert(pair&lt;key, val&gt;)：按key排序插入（支持重复key插入，无[]操作符）</td>
<td>1. erase(key)：删除所有key匹配的键值对<br>2. erase(iter)：删除指定迭代器位置元素<br>3. erase(iter1, iter2)：删除区间</td>
<td>❌ 不支持push&#x2F;push_back、无[]操作符；key可重复，需用find()&#x2F;equal_range()获取指定key的元素</td>
</tr>
</tbody></table>
<ul>
<li>所有STL算法（包括sort, reverse等）都严格遵循左闭右开区间的约定，例如反转中没有对下标 i 对应的数值进行反转操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() , s.<span class="built_in">begin</span>() + i);</span><br></pre></td></tr></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul>
<li>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn</li>
<li>unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</li>
<li>刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>深度优先遍历<br>o 前序遍历（递归法，迭代法）<br>o中序遍历（递归法，迭代法）<br>o后序遍历（递归法，迭代法）</li>
<li>广度优先遍历<br>o层次遍历（迭代法）</li>
</ul>
<p>在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p>
<p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p>下面给出前序遍历C++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是层序遍历C++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h4><p>力扣链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree">https://leetcode.cn/problems/balanced-binary-tree</a></p>
<ul>
<li>平衡二叉树定义：一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</li>
<li>注意二叉树高度和深度的区别<br><img src="/4a58e0ca36d60407739d2dca3cec9181.png" alt="alt text"></li>
</ul>
<h5 id="递归三步曲分析："><a href="#递归三步曲分析：" class="headerlink" title="递归三步曲分析："></a>递归三步曲分析：</h5><p>1.明确递归函数的参数和返回值<br>参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。<br>2.明确终止条件<br>递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0<br>3.明确单层递归的逻辑<br>如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftheight=<span class="built_in">getheight</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(leftheight==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rightheight=<span class="built_in">getheight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rightheight==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftheight-rightheight)&gt;<span class="number">1</span>?<span class="number">-1</span>:<span class="built_in">max</span>(leftheight,rightheight)<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getheight</span>(root)!=<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h4><p>力扣链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths">https://leetcode.cn/problems/binary-tree-paths</a></p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>1.递归函数参数以及返回值<br>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span></span><br></pre></td></tr></table></figure>
<p>2.考虑递归终止条件<br>找到叶子节点代表一条路径结束,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    终止处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么没有判断cur是否为空呢，因为上面的逻辑可以控制空节点不入循环。<br>接下来再来看一下终止处理的逻辑。<br>这里我们先使用vector结构的path容器来记录路径，最终转化成字符串存入题目要求的结果容器中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.确定单层递归逻辑<br>在走完一条路径后回溯到上一个节点，回溯和递归是一一对应的，有一个递归，就要有一个回溯都在花括号里面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,vector&lt;<span class="type">int</span>&gt;&amp; path,vector&lt;string&gt;&amp; result)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            string spath;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                spath+=<span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                spath+=<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            spath+=<span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(spath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left,path,result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right,path,result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题不太好理解，可以多巩固下。</p>
<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h4><p>力扣题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves">https://leetcode.cn/problems/sum-of-left-leaves</a></p>
<h5 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h5><p>递归的遍历顺序为后序遍历（左右中）</p>
<p>1.确定递归函数的参数和返回值<br>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int<br>2.确定终止条件<br>如果遍历到空节点，那么左叶子值一定是0<br>3.确定单层递归的逻辑<br>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。<br>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单层逻辑</span></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 检查当前节点的左孩子是否是左叶子</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           leftValue = root-&gt;left-&gt;val; <span class="comment">// 是左叶子，记录值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left); <span class="comment">// 不是，递归求左子树的左叶子和</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 递归求右子树的左叶子和（右子树的左叶子也是当前树的左叶子）</span></span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 当前树的左叶子和 = 左孩子的左叶子值（若有） + 左子树左叶子和 + 右子树左叶子和</span></span><br><span class="line">        <span class="keyword">return</span> leftValue + rightValue;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h4><p>力扣: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes">https://leetcode.cn/problems/count-complete-tree-nodes</a></p>
<h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><p>1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。<br>2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。<br>3.确定单层递归的逻辑：先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。<br>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="built_in">countNodes</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right=<span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left+right<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="index-category-tag">  <hr></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://cdn.jsdelivr.net/gh/IDECUBEKEIL/IDECUBEKEIL.github.io@main/img/cloud.png" alt="kiminocical"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">kiminocical</p><p class="is-size-6 is-block">OvO</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>阿瓦隆</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Post</p><a href="/archives/"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/IDECUBEKEIL"><i class="fab fa-github"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"From《"+data.from+"》</p><p>Provider-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-10-03T06:03:15.445Z">2025-10-03</time></p><p class="title"><a href="/2025/10/03/Data%20Structure%20and%20Algorithms/">Leetcode学习</a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/10/"><span class="level-start"><span class="level-item">October 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/IDECUBEKEIL/IDECUBEKEIL.github.io@main/img/logo.png" alt="Hexo" height="28"></a><p class="size-small"><span>&copy; 2025 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">川ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请留言，立即处理]</span><div class="size-small"><span>❤️Thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('undefined','undefined','undefined','undefined',undefined);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>