{"posts":[{"title":"Leetcode学习","text":"欢迎来到我的cpp代码学习网站 学习内容参考见 “代码随想录” https://programmercarl.com/ 一、数据结构与算法哈希表常见三种结构 数组 set map在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可重复 能否改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(log n) O(log n) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值（或key）是否可重复 能否更改数值（或key） 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(log n) O(log n) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 STL容器和容器适配器一些基本语法表格1：非STL容器（STL容器适配器） 具体容器 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 栈（stack） push(val)：仅从「栈顶」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「栈顶」元素（无返回值，需用top()获取栈顶值后再删） ❌ 不支持push_back/pop_back；仅支持栈顶操作（LIFO），无迭代器访问 队列（queue） push(val)：仅从「队尾」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「队首」元素（无返回值，需用front()获取队首值后再删） ❌ 不支持push_back/pop_front；仅支持队尾插、队首删（FIFO），无迭代器访问 优先级队列（priority_queue） push(val)：插入元素后自动按优先级排序（底层用vector+堆实现，对外统一用push） pop()：仅删除「优先级最高的元素」（堆顶，无返回值，需用top()获取后再删） ❌ 不支持push_back/pop_back；无顺序概念，仅按优先级操作，无迭代器访问 表格2：STL容器（含关联/非关联区分） 具体容器 STL容器类型（关联/非关联） 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 动态数组（vector） 非关联（序列容器） 1. push_back(val)：从「尾部」插入（唯一的push类接口，无push_front）2. insert(iter, val)：在指定迭代器位置插入 1. pop_back()：删除「尾部」元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间元素 ❌ 不支持push_front（头部插入效率极低）；仅尾部支持push_back/pop_back，指定位置用insert/erase 双向队列（deque） 非关联（序列容器） 1. push_back(val)：从「队尾」插入2. push_front(val)：从「队首」插入 1. pop_back()：删除「队尾」元素2. pop_front()：删除「队首」元素3. erase(iter)：删除指定迭代器位置元素 ✅ 同时支持push_back/push_front（区别于vector）；可随机访问（用[]下标），适合两端频繁操作 集合（set） 关联（有序唯一集合） insert(val)：按红黑树排序插入（无push/push_back，因按「键」有序存储，非位置存储） 1. erase(key)：按元素值删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 完全不支持push/push_back；元素有序且唯一，按值操作而非位置 多重集合（multiset） 关联（有序可重复集合） insert(val)：按红黑树排序插入（无push/push_back，支持重复值插入） 1. erase(key)：删除所有等于key的元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；元素有序可重复，按值删除时需注意是否删除所有匹配项 映射（map） 关联（有序唯一键值对） 1. insert(pair&lt;key, val&gt;)：按key排序插入2. map[key] = val：直接赋值（不存在则插入，存在则修改） 1. erase(key)：按key删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；存储键值对（key唯一），[]操作符可插入/修改值 多重映射（multimap） 关联（有序可重复键值对） insert(pair&lt;key, val&gt;)：按key排序插入（支持重复key插入，无[]操作符） 1. erase(key)：删除所有key匹配的键值对2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back、无[]操作符；key可重复，需用find()/equal_range()获取指定key的元素 所有STL算法（包括sort, reverse等）都严格遵循左闭右开区间的约定，例如反转中没有对下标 i 对应的数值进行反转操作 1reverse(s.begin() , s.begin() + i); 二叉树基础知识 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。 刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。 123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; 深度优先遍历o 前序遍历（递归法，迭代法）o中序遍历（递归法，迭代法）o后序遍历（递归法，迭代法） 广度优先遍历o层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 下面给出前序遍历C++代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 下面是层序遍历C++代码： 12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; }};","link":"/2025/10/03/hello-world/"}],"tags":[],"categories":[],"pages":[]}