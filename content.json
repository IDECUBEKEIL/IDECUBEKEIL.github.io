{"posts":[{"title":"Leetcode学习","text":"欢迎来到我的cpp代码学习网站 学习内容参考见 “代码随想录” https://programmercarl.com/ 一、数据结构与算法哈希表常见三种结构 数组 set map在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可重复 能否改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(log n) O(log n) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值（或key）是否可重复 能否更改数值（或key） 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(log n) O(log n) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 STL容器和容器适配器一些基本语法表格1：非STL容器（STL容器适配器） 具体容器 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 栈（stack） push(val)：仅从「栈顶」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「栈顶」元素（无返回值，需用top()获取栈顶值后再删） ❌ 不支持push_back/pop_back；仅支持栈顶操作（LIFO），无迭代器访问 队列（queue） push(val)：仅从「队尾」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「队首」元素（无返回值，需用front()获取队首值后再删） ❌ 不支持push_back/pop_front；仅支持队尾插、队首删（FIFO），无迭代器访问 优先级队列（priority_queue） push(val)：插入元素后自动按优先级排序（底层用vector+堆实现，对外统一用push） pop()：仅删除「优先级最高的元素」（堆顶，无返回值，需用top()获取后再删） ❌ 不支持push_back/pop_back；无顺序概念，仅按优先级操作，无迭代器访问 表格2：STL容器（含关联/非关联区分） 具体容器 STL容器类型（关联/非关联） 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 动态数组（vector） 非关联（序列容器） 1. push_back(val)：从「尾部」插入（唯一的push类接口，无push_front）2. insert(iter, val)：在指定迭代器位置插入 1. pop_back()：删除「尾部」元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间元素 ❌ 不支持push_front（头部插入效率极低）；仅尾部支持push_back/pop_back，指定位置用insert/erase 双向队列（deque） 非关联（序列容器） 1. push_back(val)：从「队尾」插入2. push_front(val)：从「队首」插入 1. pop_back()：删除「队尾」元素2. pop_front()：删除「队首」元素3. erase(iter)：删除指定迭代器位置元素 ✅ 同时支持push_back/push_front（区别于vector）；可随机访问（用[]下标），适合两端频繁操作 集合（set） 关联（有序唯一集合） insert(val)：按红黑树排序插入（无push/push_back，因按「键」有序存储，非位置存储） 1. erase(key)：按元素值删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 完全不支持push/push_back；元素有序且唯一，按值操作而非位置 多重集合（multiset） 关联（有序可重复集合） insert(val)：按红黑树排序插入（无push/push_back，支持重复值插入） 1. erase(key)：删除所有等于key的元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；元素有序可重复，按值删除时需注意是否删除所有匹配项 映射（map） 关联（有序唯一键值对） 1. insert(pair&lt;key, val&gt;)：按key排序插入2. map[key] = val：直接赋值（不存在则插入，存在则修改） 1. erase(key)：按key删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；存储键值对（key唯一），[]操作符可插入/修改值 多重映射（multimap） 关联（有序可重复键值对） insert(pair&lt;key, val&gt;)：按key排序插入（支持重复key插入，无[]操作符） 1. erase(key)：删除所有key匹配的键值对2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back、无[]操作符；key可重复，需用find()/equal_range()获取指定key的元素 所有STL算法（包括sort, reverse等）都严格遵循左闭右开区间的约定，例如反转中没有对下标 i 对应的数值进行反转操作 1reverse(s.begin() , s.begin() + i); 二叉树基础知识 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。 刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。 123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; 深度优先遍历o 前序遍历（递归法，迭代法）o中序遍历（递归法，迭代法）o后序遍历（递归法，迭代法） 广度优先遍历o层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 下面给出前序遍历C++代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 下面是层序遍历C++代码： 12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; }}; 110.平衡二叉树力扣链接：https://leetcode.cn/problems/balanced-binary-tree 平衡二叉树定义：一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 注意二叉树高度和深度的区别 递归三步曲分析 1.明确递归函数的参数和返回值参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。2.明确终止条件递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为03.明确单层递归的逻辑如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。代码如下： 1234567891011121314class Solution {public: int getheight(TreeNode* node){ if(node==NULL) return 0; int leftheight=getheight(node-&gt;left); if(leftheight==-1) return -1; int rightheight=getheight(node-&gt;right); if(rightheight==-1) return -1; return abs(leftheight-rightheight)&gt;1?-1:max(leftheight,rightheight)+1; } bool isBalanced(TreeNode* root) { return getheight(root)!=-1?true:false; }}; 257.二叉树的所有路径力扣链接：https://leetcode.cn/problems/binary-tree-paths 递归 1.递归函数参数以及返回值要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值。 1void traversal(TreeNode* node, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) 2.考虑递归终止条件找到叶子节点代表一条路径结束, 123if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { 终止处理逻辑} 为什么没有判断cur是否为空呢，因为上面的逻辑可以控制空节点不入循环。接下来再来看一下终止处理的逻辑。这里我们先使用vector结构的path容器来记录路径，最终转化成字符串存入题目要求的结果容器中，代码如下： 12345678910if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { // 遇到叶子节点 string sPath; for (int i = 0; i &lt; path.size() - 1; i++) { // 将path里记录的路径转为string格式 sPath += to_string(path[i]); sPath += &quot;-&gt;&quot;; } sPath += to_string(path[path.size() - 1]); // 记录最后一个节点（叶子节点） result.push_back(sPath); // 收集一个路径 return;} 3.确定单层递归逻辑在走完一条路径后回溯到上一个节点，回溯和递归是一一对应的，有一个递归，就要有一个回溯都在花括号里面。 12345678if (node-&gt;left) { traversal(cur-&gt;left, path, result); path.pop_back(); // 回溯}if (node-&gt;right) { traversal(cur-&gt;right, path, result); path.pop_back(); // 回溯} 最终代码如下: 12345678910111213141516171819202122232425262728293031class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; path,vector&lt;string&gt;&amp; result){ path.push_back(node-&gt;val); if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { string spath; for(int i=0;i&lt;path.size()-1;i++){ spath+=to_string(path[i]); spath+=&quot;-&gt;&quot;; } spath+=to_string(path[path.size()-1]); result.push_back(spath); return; } if(node-&gt;left!=NULL){ traversal(node-&gt;left,path,result); path.pop_back(); } if(node-&gt;right!=NULL){ traversal(node-&gt;right,path,result); path.pop_back(); } } vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;int&gt; path; vector&lt;string&gt; result; if(root==NULL) return result; traversal(root,path,result); return result; }}; 这个题不太好理解，可以多巩固下。 404.左叶子之和力扣题目链接：https://leetcode.cn/problems/sum-of-left-leaves 递归 递归的遍历顺序为后序遍历（左右中） 1.确定递归函数的参数和返回值判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int2.确定终止条件如果遍历到空节点，那么左叶子值一定是03.确定单层递归的逻辑当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。代码如下: 1234567891011121314151617181920class Solution {public: int sumOfLeftLeaves(TreeNode* root) { if (root == NULL) return 0; // 单层逻辑 int leftValue = 0; // 检查当前节点的左孩子是否是左叶子 if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { leftValue = root-&gt;left-&gt;val; // 是左叶子，记录值 } else { leftValue = sumOfLeftLeaves(root-&gt;left); // 不是，递归求左子树的左叶子和 } // 递归求右子树的左叶子和（右子树的左叶子也是当前树的左叶子） int rightValue = sumOfLeftLeaves(root-&gt;right); // 当前树的左叶子和 = 左孩子的左叶子值（若有） + 左子树左叶子和 + 右子树左叶子和 return leftValue + rightValue; }}; 222.完全二叉树的节点个数力扣: https://leetcode.cn/problems/count-complete-tree-nodes 递归 1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。3.确定单层递归的逻辑：先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。代码如下: 123456789class Solution {public: int countNodes(TreeNode* root) { if(root==NULL) return 0; int left=countNodes(root-&gt;left); int right=countNodes(root-&gt;right); return left+right+1; }}; 513.找树左下角的值力扣：https://leetcode.cn/problems/find-bottom-left-tree-value个人用的层序遍历，可以考虑递归算法求解。 1234567891011121314151617181920212223class Solution {public: int findBottomLeftValue(TreeNode* root) { queue&lt;TreeNode*&gt; que; if(root==NULL) return 0; que.push(root); TreeNode* cur; vector&lt;vector&lt;int&gt;&gt; vec1; while(!que.empty()){ int size=que.size(); vector&lt;int&gt; vec2; for(int i=0;i&lt;size;i++){ cur=que.front(); vec2.push_back(cur-&gt;val); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); } vec1.push_back(vec2); } return vec1[vec1.size()-1][0]; }}; 112.113. 路径总和力扣：https://leetcode.cn/problems/path-sum力扣：https://leetcode.cn/problems/path-sum-ii用257的思想用递归回溯找到所有路径，然后稍加修改就可以求出112，113。112代码如下： 123456789101112131415161718192021222324252627class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; path,int target,int&amp; flag){ path.push_back(node-&gt;val); if(node-&gt;left==NULL&amp;&amp;node-&gt;right==NULL){ if(accumulate(path.begin(),path.end(),0)==target){ flag=1; } return; } if(node-&gt;left){ traversal(node-&gt;left,path,target,flag); path.pop_back(); } if(node-&gt;right){ traversal(node-&gt;right,path,target,flag); path.pop_back(); } } bool hasPathSum(TreeNode* root, int targetSum) { if(root==NULL) return false; vector&lt;int&gt; p; int flag=0; traversal(root,p,targetSum,flag); return flag==1?true:false; }}; 113代码如下: 12345678910111213141516171819202122232425262728class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; path,int target, vector&lt;vector&lt;int&gt;&gt;&amp; result){ path.push_back(node-&gt;val); if(node-&gt;left==NULL&amp;&amp;node-&gt;right==NULL){ if(accumulate(path.begin(),path.end(),0)==target){ result.push_back(path); } return; } if(node-&gt;left){ traversal(node-&gt;left,path,target,result); path.pop_back(); } if(node-&gt;right){ traversal(node-&gt;right,path,target,result); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) { if(root==NULL) return {}; vector&lt;int&gt; p; vector&lt;vector&lt;int&gt;&gt; result; traversal(root,p,targetSum,result); return result; }}; 105. 从前序与中序遍历序列构造二叉树https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal 106. 从中序与后序遍历序列构造二叉树https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal思路其实都一样，通过前序或者后序遍历先找到根节点，先创建一颗只有根节点的树，利用找到根节点的值去中序遍历将其拆分成左右两个树的中序遍历，接着利用中序遍历左右两个子树的节点数量大小来拆分前序和后序的vector容器，分成左子树或者右子树的前序或者后序遍历。最后利用递归分别去递归树的每一个节点完成树的构建。105代码如下： 12345678910111213141516171819202122class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { if(preorder.size()==0||inorder.size()==0) return NULL; int rootval=preorder[0]; TreeNode* root=new TreeNode(rootval); int i; for(i=0;i&lt;inorder.size();i++){ if(inorder[i]==rootval) break; } vector&lt;int&gt; leftinorder(inorder.begin(),inorder.begin()+i); vector&lt;int&gt; rightinorder(inorder.begin()+i+1,inorder.end()); preorder.erase(preorder.begin()); vector&lt;int&gt; leftpreorder(preorder.begin(),preorder.begin()+leftinorder.size()); vector&lt;int&gt; rightpreorder(preorder.begin()+leftinorder.size(),preorder.end()); root-&gt;left=buildTree(leftpreorder,leftinorder); root-&gt;right=buildTree(rightpreorder,rightinorder); return root; }}; 106代码如下： 1234567891011121314151617181920212223class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { if(inorder.size()==0||postorder.size()==0) return NULL; int rootval=postorder[postorder.size()-1]; TreeNode* root=new TreeNode(rootval); int i; for(i=0;i&lt;inorder.size();i++){ if(inorder[i]==rootval) break; } vector&lt;int&gt; leftinorder(inorder.begin(),inorder.begin()+i); vector&lt;int&gt; rightinorder(inorder.begin()+i+1,inorder.end()); postorder.pop_back(); vector&lt;int&gt; leftpostorder(postorder.begin(),postorder.begin()+leftinorder.size()); vector&lt;int&gt; rightpostorder(postorder.begin()+leftinorder.size(),postorder.end()); root-&gt;left=buildTree(leftinorder,leftpostorder); root-&gt;right=buildTree(rightinorder,rightpostorder); return root; }}; 654.最大二叉树https://leetcode.cn/problems/maximum-binary-tree本题和105，106思路很像，都是递归方法，递归传入的元素就是左右子树，学会如何分割容器内元素。代码如下： 12345678910111213141516171819202122class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return NULL; int root=INT_MIN; int d; for(int i=0;i&lt;nums.size();i++){ if(nums[i]&gt;root){ root=nums[i]; d=i; } } TreeNode* node=new TreeNode(root); vector&lt;int&gt; left={nums.begin(),nums.begin()+d}; vector&lt;int&gt; right={nums.begin()+d+1,nums.end()}; node-&gt;left=constructMaximumBinaryTree(left); node-&gt;right=constructMaximumBinaryTree(right); return node; }}; 617.合并二叉树https://leetcode.cn/problems/merge-two-binary-trees首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。 反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。单层递归的逻辑就比较好写了，这里我们重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。 那么单层递归中，就要把两棵树的元素加到一起。接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。最终t1就是合并之后的根节点。代码如下： 123456789101112131415class Solution {public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(root1==NULL) return root2; if(root2==NULL) return root1; root1-&gt;val+=root2-&gt;val; root1-&gt;left=mergeTrees(root1-&gt;left,root2-&gt;left); root1-&gt;right=mergeTrees(root1-&gt;right,root2-&gt;right); return root1; }}; 700.二叉搜索树中的搜索给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。https://leetcode.cn/problems/search-in-a-binary-search-tree二叉搜索树是一个有序树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 注意写递归函数的时候会习惯直接写 searchBST(root-&gt;left, val)，却忘了 递归函数还有返回值。递归函数的返回值是什么? 是左子树如果搜索到了val，要将该节点返回。 如果不用一个变量将其接住，那么返回值不就没了。所以要 result = searchBST(root-&gt;left, val)。代码如下： 123456789101112131415class Solution {public: TreeNode* searchBST(TreeNode* root, int val) { if(root==NULL) return NULL; if(root-&gt;val==val) return root; TreeNode* result=NULL; if(root-&gt;val&gt;val){ result=searchBST(root-&gt;left,val); } if(root-&gt;val&lt;val){ result=searchBST(root-&gt;right,val); } return result; }}; 98.验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。https://leetcode.cn/problems/validate-binary-search-tree 易错点：不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。所以要用一个数组存放二叉树中序遍历的元素，数组的数值会从小往大递增，而不是简单的if判断相邻左右子节点的大小。代码如下： 12345678910111213141516171819class Solution {public: vector&lt;int&gt; tree; void traversal(TreeNode* node){ if(node==NULL) return; traversal(node-&gt;left); tree.push_back(node-&gt;val); traversal(node-&gt;right); } bool isValidBST(TreeNode* root) { if(root==NULL) return true; traversal(root); for(int i=1;i&lt;tree.size();i++){ if(tree[i]&lt;=tree[i-1]) return false; } return true; }}; 530.二叉搜索树的最小绝对差给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。https://leetcode.cn/problems/minimum-absolute-difference-in-bst/ 思路 注意是二叉搜索树，二叉搜索树可是有序的。遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。代码如下： 12345678910111213141516171819202122class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec){ if(node==NULL) return; traversal(node-&gt;left,vec); vec.push_back(node-&gt;val); traversal(node-&gt;right,vec); return; } int getMinimumDifference(TreeNode* root) { if(root==NULL) return 0; vector&lt;int&gt; result; traversal(root,result); int d=INT_MAX; for(int i=1;i&lt;result.size();i++){ if(d&gt;result[i]-result[i-1]){ d= result[i]-result[i-1]; } } return d; }}; 501.二叉搜索树中的众数https://leetcode.cn/problems/find-mode-in-binary-search-tree/给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。本题有两种思路，先介绍一种普遍思路，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。代码如下： 123456789101112131415161718192021222324252627282930class Solution {public: void traversal(TreeNode*node,unordered_map&lt;int,int&gt;&amp; m){ if(node==NULL) return; traversal(node-&gt;left,m); m[node-&gt;val]++; traversal(node-&gt;right,m); return; } vector&lt;int&gt; findMode(TreeNode* root) { if(root==NULL) return {}; unordered_map&lt;int,int&gt; m; traversal(root,m); vector&lt;int&gt; result; int maxCount=0; // 先找到最大频率 for (auto&amp; pair : m) { if (pair.second &gt; maxCount) { maxCount = pair.second; } } // 再收集所有频率等于最大频率的元素 for (auto&amp; pair : m) { if (pair.second == maxCount) { result.push_back(pair.first); } } return result; }}; 给出一些代码语法解释： 1for (auto&amp; pair : m) 对于unordered_map来说，它的每个元素是一个「键值对（key-value pair）」，类型为std::pair&lt;const Key, Value&gt;（比如unordered_map&lt;int, int&gt;的元素类型是pair&lt;const int, int&gt;）。因此auto会自动推导出pair的类型为std::pair&lt;const int, int&gt;。这里的&amp;表示「引用」，作用是直接引用容器中的元素，而不是复制元素。 如果不加&amp;（即for (auto pair : m)）：每次循环会创建一个pair的副本（复制容器中的元素到pair）。对于简单类型（如int），复制成本低；但对于复杂类型（如map的键值对pair，尤其是当键或值是大型对象时），复制会产生额外的内存开销和性能损耗。 加&amp;（即for (auto&amp; pair : m)）：pair是容器中元素的引用，直接指向容器中的原始元素，不会产生复制。这能提高遍历效率，尤其是对于大型容器或复杂元素类型。 123for (元素声明 : 容器) { // 循环体（使用声明的元素）} 其中，元素声明 用于定义一个变量接收容器中的元素（通常用 auto 自动推导类型），容器 可以是 STL 容器（如 vector、set、map）、数组等。 接下来考虑第二种思路，因为题目是二叉搜索树，它中序遍历就是有序的。遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int count=0; int maxcount=0; TreeNode*pre=nullptr; void traversal(TreeNode*node,vector&lt;int&gt;&amp; vec){ if(node==NULL) return; traversal(node-&gt;left,vec); if(pre==nullptr) { count=1; } else if(pre-&gt;val==node-&gt;val){ count++; } else{ count=1; } pre=node; if(count&gt;maxcount){ maxcount=count; vec.clear(); vec.push_back(node-&gt;val); } else if(count==maxcount){ vec.push_back(node-&gt;val); } traversal(node-&gt;right,vec); return; } vector&lt;int&gt; findMode(TreeNode* root) { if(root==NULL) return {}; vector&lt;int&gt; result; traversal(root,result); return result; }}; 236. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/本题有难度，递归思路不好想。递归三部曲 确定递归函数返回值以及参数需要找到节点p，q同时函数返回值应该是一个节点。 1TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 确定终止条件当root是p或q时：说明在当前路径上找到了目标节点，返回该节点（告知上层 “这里有一个目标节点”）。当root是NULL时：说明当前子树中没有p和q，返回NULL（告知上层 “这里没找到”）。终止条件的核心是：遇到目标节点或空节点时，停止深入，返回当前节点作为 “结果信号” 1if (root == q || root == p || root == NULL) return root; 确定单层递归的逻辑对于当前节点root，需要做三件事：1.递归左子树：获取左子树的 “有效祖先节点”（left）；2.递归右子树：获取右子树的 “有效祖先节点”（right）；3.根据left和right判断当前节点 12345if (left == NULL &amp;&amp; right != NULL) return right;else if (left != NULL &amp;&amp; right == NULL) return left;else { // (left == NULL &amp;&amp; right == NULL) return NULL;} 整体代码如下: 123456789101112class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root==q||root==p||root==NULL) return root; TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q); TreeNode* right=lowestCommonAncestor(root-&gt;right,p,q); if(left!=NULL&amp;&amp;right!=NULL) return root; else if(left==NULL&amp;&amp;right!=NULL) return right; else if(left!=NULL&amp;&amp;right==NULL) return left; else return NULL; }}; 算法通过后序遍历的自底向上特性，确保 “先遇到深层节点，再遇到高层节点”。一旦在某个节点满足 “左右子树各含一个目标节点”，就会立即返回该节点。 235.二叉搜索树的最近公共祖先https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。这道题用236的通解显然可以求，但题目是二叉搜索树，可以用二叉搜索树的性质来修改逻辑。 那么如果 cur-&gt;val 大于 p-&gt;val，同时 cur-&gt;val 大于q-&gt;val，那么就应该向左遍历（说明目标区间在左子树上）。 如果 cur-&gt;val 小于 p-&gt;val，同时 cur-&gt;val 小于 q-&gt;val，那么就应该向右遍历（目标区间在右子树）。 剩下的情况，就是cur节点在区间（p-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= q-&gt;val）或者 （q-&gt;val &lt;= cur-&gt;val &amp;&amp; cur-&gt;val &lt;= p-&gt;val）中，那么cur就是最近公共祖先了，直接返回cur。 代码如下: 1234567891011121314151617class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root==NULL||root==p||root==q) return root; if(root-&gt;val&gt;p-&gt;val&amp;&amp;root-&gt;val&gt;q-&gt;val){ TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q); if(left!=NULL) return left; } else if(root-&gt;val&lt;p-&gt;val&amp;&amp;root-&gt;val&lt;q-&gt;val){ TreeNode* right=lowestCommonAncestor(root-&gt;right,p,q); if(right!=NULL) return right; } return root; } }; 701.二叉搜索树中的插入操作https://leetcode.cn/problems/insert-into-a-binary-search-tree/给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 思路 只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。代码如下: 123456789class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(root==nullptr) return new TreeNode(val); if(root-&gt;val&gt;val) root-&gt;left=insertIntoBST(root-&gt;left, val); if(root-&gt;val&lt;val) root-&gt;right=insertIntoBST(root-&gt;right, val); return root; }}; 450.删除二叉搜索树中的节点https://leetcode.cn/problems/delete-node-in-a-bst/给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 递归三部曲 确定递归函数参数以及返回值最终函数返回的肯定是删除后的新树，返回值是树的节点，参数为树的节点和删除的节点值 1TreeNode* deleteNode(TreeNode* root, int key) 确定终止条件遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了 1if (root == nullptr) return root; 确定单层递归的逻辑如果找到了删除的节点，判断该节点左右子节点是否为空1.若都为空，删除这个节点，返回空。2.若一个为空一个不为空，返回这个节点不为空的子树，同时删除这个节点3.若都不为空，找到该节点的前驱（左子树中最大的节点）或后继（右子树中最小的节点），用它的值替换待删除节点的值。(保证BST的有序性)然后删除这个前驱或后继节点 123456TreeNode* node=root-&gt;right;while(node-&gt;left!=nullptr){ node=node-&gt;left;}root-&gt;val=node-&gt;val;root-&gt;right=deleteNode(root-&gt;right,node-&gt;val); 如果没找到，判断删除节点的值与目前节点的大小比较，分别去左子树或者右子树去寻找删除。 整体代码如下: 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: TreeNode* deleteNode(TreeNode* root, int key) { if(root==NULL) return root; if(root-&gt;val==key){ if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) { delete root; return NULL; } else if(root-&gt;left==NULL&amp;&amp;root-&gt;right!=NULL){ TreeNode* retNode=root-&gt;right; delete root; return retNode; } else if(root-&gt;left!=NULL&amp;&amp;root-&gt;right==NULL){ TreeNode* retNode=root-&gt;left; delete root; return retNode; } else if(root-&gt;left!=NULL&amp;&amp;root-&gt;right!=NULL){ TreeNode* node=root-&gt;right; while(node-&gt;left!=nullptr){ node=node-&gt;left; } root-&gt;val=node-&gt;val; root-&gt;right=deleteNode(root-&gt;right,node-&gt;val); } } if(root-&gt;val&gt;key){ root-&gt;left=deleteNode(root-&gt;left,key); } if(root-&gt;val&lt;key){ root-&gt;right=deleteNode(root-&gt;right,key); } return root; }}; 669. 修剪二叉搜索树https://leetcode.cn/problems/trim-a-binary-search-tree/给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 递归三部曲 确定递归函数的参数和返回值参数：TreeNode* root（当前遍历的节点）、int low（下界）、int high（上界）。返回值：TreeNode*（修剪后，当前子树的新根节点） 确定终止条件当 当前节点为空时，无需修剪，直接返回空。 确定单层递归的逻辑如果root（当前节点）的元素小于low的数值，那么应该递归右子树进行修剪，并返回修剪完后的右子树。如果root (当前节点) 的元素大于high的，那么应该递归左子树进行修剪，并返回修剪完后的左子树。如果当前节点的值在区间里面，则分别进行左右子树修剪后返回。 代码如下: 123456789101112131415161718192021 class Solution {public: TreeNode* trimBST(TreeNode* root, int low, int high) { if(root==NULL) return NULL; // 情况1：当前节点值 &lt; low → 该节点及其左子树都应被剪掉（左子树值更小） if (root-&gt;val &lt; low) { return trimBST(root-&gt;right, low, high); // 返回右子树修剪后的结果（右子树可能有符合条件的节点） } // 情况2：当前节点值 &gt; high → 该节点及其右子树都应被剪掉（右子树值更大） if (root-&gt;val &gt; high) { return trimBST(root-&gt;left, low, high); // 返回左子树修剪后的结果（左子树可能有符合条件的节点） } // 情况3：当前节点值在 [low, high] 范围内 → 保留该节点，修剪其左右子树 root-&gt;left = trimBST(root-&gt;left, low, high); // 修剪左子树，更新左指针 root-&gt;right = trimBST(root-&gt;right, low, high); // 修剪右子树，更新右指针 return root; // 返回修剪后的当前节点（作为子树新根） }}; 108. 将有序数组转换为二叉搜索树将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/ 思路 在给定有序数组中，先取中间位置值为根节点树，接着分别取中间节点的左右两边为其左右子树，递归的构造出平衡二叉搜索树。 注意二分法时取数组中间元素的位置最好这样写，避免数值越界。 同时递归判断条件是left&gt;right返回NULL，结束递归。 1int mid = left + ((right - left) / 2); 整体代码如下： 12345678910111213141516class Solution {private: TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) { if (left &gt; right) return nullptr; int mid = left + ((right - left) / 2); TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = traversal(nums, left, mid - 1); root-&gt;right = traversal(nums, mid + 1, right); return root; }public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { TreeNode* root = traversal(nums, 0, nums.size() - 1); return root; }}; 538.把二叉搜索树转换为累加树https://leetcode.cn/problems/convert-bst-to-greater-tree/给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 思路应该采用反中序遍历（右→根→左），用一个全局变量记录 “已遍历节点的累加和”，因为每一个节点的值都应该是它右边所有节点值的和，每次遍历到当前节点时： 1.先递归处理右子树（获取所有更大节点的和）； 2.用当前节点值加上累加和，更新当前节点值； 3.更新累加和为新的节点值； 4.最后递归处理左子树。 代码如下： 123456789101112131415class Solution {public: int sum=0; void traversal(TreeNode* node){ if(node==nullptr) return; traversal(node-&gt;right); sum+=node-&gt;val; node-&gt;val=sum; traversal(node-&gt;left); } TreeNode* convertBST(TreeNode* root) { traversal(root); return root; }}; 二叉树小结二叉树最重要是要掌握递归的思路，熟悉递归三部曲，确定终止条件和单层逻辑后就可以递归，只需相信递归能正确返回子树的结果，再用单层逻辑组合这些结果即可。https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html 回溯算法基础知识回溯三部曲 回溯函数模板返回值以及参数在回溯算法中，我的习惯是函数起名字为backtracking。回溯算法中函数返回值一般为void。再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。 回溯函数终止条件既然是树形结构，那么我们在讲解二叉树的递归的时候，就知道遍历树形结构一定要有终止条件。所以回溯也有要终止条件。什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 回溯搜索的遍历过程for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。 分析完过程，回溯算法模板框架如下： 123456789101112void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 }} 第77题. 组合https://leetcode.cn/problems/combinations/给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]利用回溯三部曲，同时考虑对遍历的范围进行剪枝优化。 剪枝条件的推导已知：当前path已有m = path.size()个元素，还需要need = k - m个元素。从i到n的元素总数是：n - i + 1（因为包含i和n本身）。为了能凑够need个元素，必须满足：n - i + 1 &gt;= need。对不等式变形： 12n - i + 1 &gt;= need =&gt; i &lt;= n + 1 - need 整体代码如下: 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; result; void backtracking(int n,int k,int idx){ if(path.size()==k){ result.push_back(path); return; } for(int i=idx;i&lt;=n-(k-path.size())+1;i++){ path.push_back(i); backtracking(n,k,i+1); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracking(n,k,1); return result; }}; 216.组合总和IIIhttps://leetcode.cn/problems/combination-sum-iii/找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 本题和上题类似都是一个套路模板，添加了求和的逻辑，注意在回溯删除元素后，求和的sum值也应该减去对于删除的元素值。同时考虑若当前元素和大于题目要求不需要递归遍历直接return 进行剪枝优化。 代码如下: 12345678910111213141516171819202122232425262728class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum=0; void backtracking(int k,int n,int idx){ if(sum&gt;n){ return; } if(path.size()==k){ if(sum==n){ result.push_back(path); } return; } for(int i=idx;i&lt;=9-(k-path.size())+1;i++){ path.push_back(i); sum+=i; backtracking(k,n,i+1); path.pop_back(); sum-=i; } } vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { backtracking(k,n,1); return result; }}; 17.电话号码的字母组合https://leetcode.cn/problems/letter-combinations-of-a-phone-number/给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 回溯三部曲 1.确定回溯函数参数 首先需要一个字符串path来收集叶子节点的结果，然后用一个字符串数组result保存起来，这两个变量我依然定义为全局。 再来看参数，参数指定是有题目中给的string digits，然后还要有一个参数就是int型的idx。 注意这个idx可不是 77.组合 (opens new window)和216.组合总和III (opens new window)中的startIndex了。 这个idx是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时idx也表示树的深度。 2.确定终止条件 例如输入用例”23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。那么终止条件就是如果k等于输入的数字个数（digits.size）了结束本层递归。 3.确定单层遍历逻辑首先要取idx指向的数字，并找到对应的字符集,然后for循环来处理这个字符集。注意这里for循环，可不像是在回溯算法：求组合问题！ (opens new window)和回溯算法：求组合总和！ (opens new window)中从startIndex开始遍历的。因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而77. 组合 (opens new window)和216.组合总和III (opens new window)都是求同一个集合中的组合！ 注意：输入1 * #按键等等异常情况 代码中最好考虑这些异常情况，但题目的测试数据中应该没有异常情况的数据，所以我就没有加了。 但是要知道会有这些异常，如果是现场面试中，一定要考虑到！整体代码如下: 123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; result; string path; vector&lt;string&gt; vec={&quot; &quot;,&quot; &quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;}; void backtracking(int k,int idx,string&amp; digits){ if(path.size()==k){ result.push_back(path); return; } int dig=digits[idx]-'0'; //这里运算是换成ASCII码进行运算的，将index指向的数字转为int string v=vec[dig]; for(int i=0;i&lt;v.size();i++){ path.push_back(v[i]); backtracking(k,idx+1,digits); //切换到下一个数字对应的字母集合进行遍历。 path.pop_back(); } } vector&lt;string&gt; letterCombinations(string digits) { if(digits.size()==0) return {}; int k=digits.size(); backtracking(k,0,digits); return result; }}; 39. 组合总和https://leetcode.cn/problems/combination-sum/给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。本题可以和77和216两题对比。 回溯三部曲 1.递归函数参数这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入） 首先是题目中给出的参数，集合candidates, 和目标值target。 此外我还定义了int型的sum变量来统计单一结果path里的总和，其实这个sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了sum。 本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？ 我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：77.组合 (opens new window)，216.组合总和III (opens new window)。 如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：17.电话号码的字母组合(opens new window) 注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路. 2.递归终止条件从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。 3.单层搜索的逻辑单层for循环依然是从startIndex开始，搜索candidates集合。 注意本题和77.组合 (opens new window)、216.组合总和III (opens new window)的一个区别是：本题元素为可重复选取的。 如何重复选取呢，看代码，注释部分： 1234567for (int i = startIndex; i &lt; candidates.size(); i++) {sum += candidates[i];path.push_back(candidates[i]);backtracking(candidates, target, sum, i); // 关键点:不用i+1了，表示可以重复读取当前的数sum -= candidates[i]; // 回溯path.pop_back(); // 回溯} 考虑剪枝优化，上面的版本一的代码可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。 其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。 那么可以在for循环的搜索范围上做做文章了。 对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。整体代码如下: 1234567891011121314151617181920212223242526class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; candidates, int target,int sum,int idx) { if (sum &gt; target) { return; } if (sum == target) { result.push_back(path); return; } for (int i =idx; i &lt; candidates.size()&amp;&amp;sum + candidates[i] &lt;= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i); // 关键点:不用i+1了，表示可以重复读取当前的数 sum -= candidates[i]; // 回溯 path.pop_back(); // 回溯} } vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { backtracking(candidates,target,0,0); return result; }}; 40.组合总和IIhttps://leetcode.cn/problems/combination-sum-ii/给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合注意把上述几个组合问题对比区分，去重还是不去重，元素可以重复还是不可以重复本题的难点在于区别2个问题中：集合（数组candidates）有重复元素，但还不能有重复的组合。 与39.组合总和 (opens new window)套路相同，此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。 这个集合去重的重任就是used来完成的。这里与39.组合总和 (opens new window)最大的不同就是要去重了。 前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。 如果candidates[i] == candidates[i - 1] 并且 used[i - 1] == false，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]。 此时for循环里就应该做continue的操作。整体代码如下： 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; candidates, int target,int sum,int idx,vector&lt;bool&gt;&amp; use){ if(sum==target){ result.push_back(path); } for(int i=idx;i&lt;candidates.size()&amp;&amp;sum+candidates[i]&lt;=target;i++){ // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 要对同一树层使用过的元素进行跳过 if(i&gt;0&amp;&amp;candidates[i]==candidates[i-1]&amp;&amp;use[i-1]==false){ continue; } path.push_back(candidates[i]); sum+=candidates[i]; use[i]=true; backtracking(candidates,target,sum,i+1,use);// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次 path.pop_back(); sum-=candidates[i]; use[i]=false; } } vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;bool&gt; use(candidates.size(),false); sort(candidates.begin(),candidates.end()); backtracking(candidates,target,0,0,use); return result; }}; 131.分割回文串https://leetcode.cn/problems/palindrome-partitioning/给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ] 回溯三部曲 递归函数参数 全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里） 本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。 递归函数终止条件在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。如果起始位置startIndex已经大于s的大小，说明已经找到了一组分割方案了。 单层搜索的逻辑来看看在递归循环中如何截取子串呢？ 在for (int i = startIndex; i &lt; s.size(); i++)循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。 首先判断这个子串是不是回文，如果是回文，就加入在vector path中，path用来记录切割过的回文子串。判断回文用双指针法。 整体代码如下: 1234567891011121314151617181920212223242526272829303132333435363738class Solution {private: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 放已经回文的子串 void backtracking (const string&amp; s, int startIndex) { // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了 if (startIndex &gt;= s.size()) { result.push_back(path); return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isPalindrome(s, startIndex, i)) { // 是回文子串 // 获取[startIndex,i]在s中的子串 string str = s.substr(startIndex, i - startIndex + 1);//字符串切割函数substr(起始位置，长度) path.push_back(str); } else { // 不是回文，跳过 continue; } backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯过程，弹出本次已经添加的子串 } } bool isPalindrome(const string&amp; s, int start, int end) { for (int i = start, j = end; i &lt; j; i++, j--) { if (s[i] != s[j]) { return false; } } return true; }public: vector&lt;vector&lt;string&gt;&gt; partition(string s) { result.clear(); path.clear(); backtracking(s, 0); return result; }}; 93.复原IP地址https://leetcode.cn/problems/restore-ip-addresses/给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。其实只要意识到这是切割问题，切割问题就可以使用回溯搜索法把所有可能性搜出来，和刚做过的131.分割回文串 (opens new window)就十分类似了。本题主要是对切割的字符串合不合理进行判断。 排除超范围的子串(每个整数位于 0 到 255 之间组成) 排除前导0 每个地址由四个整数组成startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。 本题我们还需要一个变量pointNum，记录添加逗点的数量，来判断是不是取了四个整数组成一个完整的地址。代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;string&gt; result; string str; int sumpoint = 0; void backtracking(string&amp; s, int idx) { if (idx == s.size() &amp;&amp; sumpoint == 4) { result.push_back(str.substr(0, str.size() - 1)); // 去掉最后一个点 return; } for (int i = idx; i &lt; s.size()&amp;&amp;sumpoint&lt;4; i++) { string sstr = s.substr(idx, i - idx + 1); //排除前导零 if (sstr.size() &gt; 1 &amp;&amp; sstr[0] == '0') break; //转换为数字并判断合法范围 int num = stoi(sstr); if (num &lt; 0 || num &gt; 255) break; //选择这段 str += sstr + &quot;.&quot;; sumpoint++; //递归 backtracking(s, i + 1); //回溯撤销本次添加 sumpoint--; str.erase(str.end() - (sstr.size() + 1), str.end()); //不能用pop，因为pop只能每次去掉一个字符，不能去掉添加的一个字符串 } } vector&lt;string&gt; restoreIpAddresses(string s) { if (s.size() &lt; 4 || s.size() &gt; 12) return result; backtracking(s, 0); return result; }}; 本题遇见不合法的字符串用了break，意味着再往下递归没有意义，40题用了continue，意味着跳过这一个数，选择同一层的下一个数。 当前这条路不行，后面也不行 → break（剪枝），剪掉整支树，不再向下或右延伸。 当前这条路不行，但后面可能行 → continue（跳过），跳过当前节点，继续尝试同一层的兄弟节点 场景 举例 选择 后面更长的选择也不合法（如超范围、前导零） IP地址题 break 当前重复但后面仍可能合法（如同层去重） 组合总和 II continue 满足目标条件后立即返回 sum == target return（或不进入循环） 超过目标提前终止 sum + candidates[i] &gt; target break 跳过重复值 candidates[i] == candidates[i-1] &amp;&amp; use[i-1]==false continue 78.子集https://leetcode.cn/problems/subsets/给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 思路 其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。 那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。代码如下： 1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) { result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己 if (startIndex &gt;= nums.size()) { // 终止条件可以不加 return; } for (int i = startIndex; i &lt; nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }}; 90.子集IIhttps://leetcode.cn/problems/subsets-ii/给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。结合40.组合总和II 和 78.子集这道题很容易写出了，代码如下： 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums,int idx,vector&lt;int&gt;&amp; use){ result.push_back(path); if(idx&gt;=nums.size()){ return; } for(int i=idx;i&lt;nums.size();i++){ if(i&gt;0&amp;&amp;nums[i-1]==nums[i]&amp;&amp;use[i-1]==0) continue; path.push_back(nums[i]); use[i]++; backtracking(nums,i+1,use); use[i]--; path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; use(nums.size(),0); sort(nums.begin(),nums.end()); backtracking(nums,0,use); return result; }}; 491.递增子序列https://leetcode.cn/problems/non-decreasing-subsequences/给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。递增子序列，要子集，要去重，还不能先排序。注意和90题的差别。在90.子集II (opens new window)中我们是通过排序，再加一个标记数组来达到去重的目的。 而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。 所以不能使用之前的去重逻辑！其实用数组来做哈希表，来记录本层元素是否重复使用。在每次进行回溯时，新的一层use都会重新定义（清空），所以要知道use只负责本层，因为这个use是局部变量，当函数返回时自动销毁，不影响上层或其他分支，区别于90题use是全局共享的，要不断更新use的值。代码如下: 12345678910111213141516171819202122232425262728class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums,int idx){ if(path.size()&gt;1){ result.push_back(path); } if(idx&gt;=nums.size()){ return; } int use[201]={0}; for(int i=idx;i&lt;nums.size();i++){ if(!path.empty()&amp;&amp;path.back()&gt;nums[i]||use[nums[i]+100]==1){ continue; } path.push_back(nums[i]); use[nums[i]+100]=1; backtracking(nums,i+1); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) { if(nums.size()&lt;=1) return {}; backtracking(nums,0); return result; }}; 46.全排列https://leetcode.cn/problems/permutations/给定一个 没有重复 数字的序列，返回其所有可能的全排列。注意排列和组合的区别排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。 可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。 但排列问题需要一个used数组，标记已经选择的元素。 回溯三部曲 递归函数参数 123vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) 递归终止条件当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。 1234if (path.size() == nums.size()) { result.push_back(path); return; } 单层搜索的逻辑因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。 而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。 12345678for (int i = 0; i &lt; nums.size(); i++) { if (used[i] == true) continue; // path里已经收录的元素，直接跳过 used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } 整体代码如下: 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) { // 此时说明找到了一组 if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i &lt; nums.size(); i++) { if (used[i] == true) continue; // path里已经收录的元素，直接跳过 used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, used); return result; }}; 47.全排列 IIhttps://leetcode.cn/problems/permutations-ii/给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。结合46题和40题去重逻辑，很容易得到如下代码： 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums,vector&lt;int&gt; used){ if(path.size()==nums.size()){ result.push_back(path); return; } for(int i=0;i&lt;nums.size();i++){ if(used[i]==1||i&gt;0&amp;&amp;used[i-1]==0&amp;&amp;nums[i-1]==nums[i]) continue; path.push_back(nums[i]); used[i]=1; backtracking(nums,used); path.pop_back(); used[i]=0; } } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; used(nums.size(),0); sort(nums.begin(),nums.end()); backtracking(nums,used); return result; }}; 总结https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html回溯算法能解决如下问题： 组合问题：N个数里面按一定规则找出k个数的集合 排列问题：N个数按一定规则全排列，有几种排列方式 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 棋盘问题：N皇后，解数独等等 贪心算法基础知识贪心的本质是选择每一阶段的局部最优，从而达到全局最优。https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 455.分发饼干https://leetcode.cn/problems/assign-cookies/这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。 代码如下： 1234567891011121314151617class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { int result=0; sort(g.begin(),g.end()); sort(s.begin(),s.end()); int j=s.size()-1; for(int i=g.size()-1;i&gt;=0;i--){ if(j&gt;=0&amp;&amp;s[j]&gt;=g[i]) { result++; j--; } } return result; }}; 376. 摆动序列https://leetcode.cn/problems/wiggle-subsequence/如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列 仅有一个元素或者含两个不等元素的序列也视作摆动序列。如果一个序列数字全相等，返回值就是1。代码如下： 123456789101112131415161718192021222324class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 1) return nums.size(); // 边界情况：空或单元素 int prevSign = 0; // 前一个有效差值的符号（1正，-1负，0初始/无有效） int length = 1; // 初始长度至少为1（单个元素） for (int i = 1; i &lt; nums.size(); ++i) { int diff = nums[i] - nums[i-1]; if (diff == 0) continue; // 跳过相等的情况 int currSign = diff &gt; 0 ? 1 : -1; // 当前差值的符号 // 若当前符号与前一个不同，说明出现摆动 if (currSign != prevSign) { length++; } prevSign = currSign; // 更新前一个符号 } return length; }}; 53. 最大子序和https://leetcode.cn/problems/maximum-subarray/给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 贪心解法 贪心贪的是哪里呢？ 如果 -2 1 在一起，计算起点的时候，一定是从 1 开始计算，因为负数只会拉低总和，这就是贪心贪的地方！ 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。 全局最优：选取最大“连续和” 局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。 从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。 代码如下： 123456789101112131415class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int result = INT32_MIN; int count = 0; for (int i = 0; i &lt; nums.size(); i++) { count += nums[i]; if (count &gt; result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置） result = count; } if (count &lt;= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 } return result; }}; 122.买卖股票的最佳时机 IIhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/ 贪心算法如果想到其实最终利润是可以分解的，那么本题就很容易了！ 如何分解呢？ 假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。 此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！ 那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。 其实我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间。 那么只收集正利润就是贪心所贪的地方！ 局部最优：收集每天的正利润，全局最优：求得最大利润。 代码如下: 123456789101112class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int sum=0; for(int i=1;i&lt;prices.size();i++){ int d=prices[i]-prices[i-1]; if(d&gt;0) sum+=d; } return sum; }}; 55. 跳跃游戏https://leetcode.cn/problems/jump-game/ 我在写这道题是以遇没遇到0来判断，只要能跳过0这个断路就一定能走到最后。 1234567891011121314151617181920class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int p=0; if(nums[0]==0&amp;&amp;nums.size()!=1) return false; if(nums[0]==0) return true; for(int i=0;i&lt;nums.size();i++){ if(nums[i]==0&amp;&amp;i!=nums.size()-1){ for(int j=0;j&lt;i;j++){ if(nums[j]&gt;i-j){ p=1; //代表可以跳过这次0 } } if(p==0) return false; p=0; //标签重置，在下一次遇到0时继续判断 } } return true; }}; 贪心思路这个问题可以转化为跳跃覆盖范围究竟可不可以覆盖到终点 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。 代码如下: 123456789101112class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int cover = 0; if (nums.size() == 1) return true; // 只有一个元素，就是能达到 for (int i = 0; i &lt;= cover; i++) { // 注意这里是小于等于cover cover = max(i + nums[i], cover); if (cover &gt;= nums.size() - 1) return true; // 说明可以覆盖到终点了 } return false; }}; 这道题目关键点在于：不用拘泥于每次究竟跳几步，而是看覆盖范围，覆盖范围内一定是可以跳过来的，不用管是怎么跳的。 45.跳跃游戏 IIhttps://leetcode.cn/problems/jump-game-ii/ 本题相对于55.跳跃游戏 (opens new window)还是难了不少。 但思路是相似的，还是要看最大覆盖范围。 本题要计算最少步数，那么就要想清楚什么时候步数才一定要加一呢？ 贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。 思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。 所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！ 这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。 如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。 代码如下: 123456789101112131415161718class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return 0; int step=1; // 记录走的最大步数 int cur=0; // 当前覆盖最远距离下标 int next=0; // 下一步覆盖最远距离下标 for(int i=0;i&lt;nums.size();i++){ next=max(nums[i]+i,next); // 更新下一步覆盖最远距离下标 if(i==cur){ // 遇到当前覆盖最远距离下标 cur=next; // 更新当前覆盖最远距离下标 if(cur&gt;=nums.size()-1) break; // 当前覆盖最远距到达集合终点，不用做step++操作了，直接结束 step++; } } return step; }}; 1005.K次取反后最大化的数组和https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/ 每次将最小值取反就能保证最终和最大。 1234567891011121314class Solution {public: int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) { while(k--){ sort(nums.begin(),nums.end()); nums[0]=-nums[0]; } int sum=0; for(int j=0;j&lt;nums.size();j++){ sum+=nums[j]; } return sum; }}; 134. 加油站https://leetcode.cn/problems/gas-station/ 贪心算法 首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。 每个加油站的剩余量rest[i]为gas[i] - cost[i]。 i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。因为如果存在解，则 保证 它是 唯一 的，所以如果总油量减去总消耗大于等于零那么一定可以跑完一圈，起始点就在数组下标里面选，只需遍历一次更新起始下标。 那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。 123456789101112131415161718class Solution {public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) { int rest=0; int total=0; int start=0; for(int i=0;i&lt;gas.size();i++){ rest+=gas[i]-cost[i]; total+=gas[i]-cost[i]; if(rest&lt;0){ start=i+1; rest=0; } } if(total&lt;0) return -1; return start; }}; 860.柠檬水找零https://leetcode.cn/problems/lemonade-change/ 12345678910111213141516171819202122232425class Solution {public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { int five=0; int ten=0; for(int i=0;i&lt;bills.size();i++){ if(bills[i]==5) five++; else if(bills[i]==10){ ten++; five--; } else if(bills[i]==20){ if(ten*10+five*5&lt;15) return false; if(ten&gt;=1) { five--; ten--; } else{ five=five-3; } } if(five&lt;0) return false; } return true; }}; 135. 分发糖果https://leetcode.cn/problems/candy/ 思路 这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。 先确定右边评分大于左边的情况（也就是从前向后遍历） 此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果 局部最优可以推出全局最优。 如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] = candyVec[i - 1] + 1 再确定左孩子大于右孩子的情况（从后向前遍历） 如果 ratings[i] &gt; ratings[i + 1]，此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。 那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。 局部最优可以推出全局最优。 所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多。 12345678910111213141516171819class Solution {public: int candy(vector&lt;int&gt;&amp; ratings) { vector&lt;int&gt; c(ratings.size(),1); int result=0; for(int i=1;i&lt;ratings.size();i++){ if(ratings[i]&gt;ratings[i-1]) c[i]=c[i-1]+1; } for(int i=ratings.size()-2;i&gt;=0;i--){ if(ratings[i]&gt;ratings[i+1]) c[i]=max(c[i+1]+1,c[i]); } for(int cdy:c){ result+=cdy; } return result; }}; 406.根据身高重建队列https://leetcode.cn/problems/queue-reconstruction-by-height/ 两步法，先确定一个维度h，再确定k 先按身高排序那么按照身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。 此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高 那么只需要按照k为下标重新插入队列就可以了 插入，确定第二个维度k 按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。 所以在按照身高从大到小排序后： 局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性 全局最优：最后都做完插入操作，整个队列满足题目队列属性 回归本题，整个插入过程如下： 排序完的people： [ [7,0], [7,1], [6,1], [5,0], [5,2], [4,4] ] 插入的过程： 插入[7,0]：[ [7,0] ] 插入[7,1]：[ [7,0],[7,1] ] 插入[6,1]：[ [7,0],[6,1],[7,1] ] 插入[5,0]：[ [5,0],[7,0],[6,1],[7,1] ] 插入[5,2]：[ [5,0],[7,0],[5,2],[6,1],[7,1] ] 插入[4,4]：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ] 123456789101112131415161718class Solution {public://static 是必须的：否则因隐含 this 指针导致参数数量不匹配，编译失败。//const 是实际必须的：否则无法兼容 sort 传递的常量引用，导致编译错误，且无法保证参数不被意外修改。 static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) { if (a[0] == b[0]) return a[1] &lt; b[1]; //如果判断成立，a排在b前面 return a[0] &gt; b[0]; } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { sort (people.begin(), people.end(), cmp); vector&lt;vector&lt;int&gt;&gt; que; for (int i = 0; i &lt; people.size(); i++) { int position = people[i][1]; que.insert(que.begin() + position, people[i]); } return que; }}; 有兴趣可以看看链表插入操作 123456789101112131415161718192021class Solution {public: // 身高从大到小排（身高相同k小的站前面） static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) { if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0]; } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { sort (people.begin(), people.end(), cmp); list&lt;vector&lt;int&gt;&gt; que; // list底层是链表实现，插入效率比vector高的多 for (int i = 0; i &lt; people.size(); i++) { int position = people[i][1]; // 插入到下标为position的位置 std::list&lt;vector&lt;int&gt;&gt;::iterator it = que.begin(); while (position--) { // 寻找在插入位置 it++; } que.insert(it, people[i]); } return vector&lt;vector&lt;int&gt;&gt;(que.begin(), que.end()); }}; 452. 用最少数量的箭引爆气球https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/ 为了让气球尽可能的重叠，需要对数组进行排序。 按数组起始位置从小到大排序。接着判断区间是否重叠。如果重叠了只需要起始的一支箭，不重叠箭就要加一， 注意：本题中[1,2],[2,3]满足重叠的，只需要一支箭(435. 无重叠区间定义中，这两个区间不重叠) 123456789101112131415161718class Solution {public: static bool cmp(const vector&lt;int&gt;&amp; a,const vector&lt;int&gt;&amp; b){ return a[0]&lt;b[0]; } int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if(points.size()==0) return 0; int result=1; sort(points.begin(),points.end(),cmp); for(int i=1;i&lt;points.size();i++){ if(points[i][0]&gt;points[i-1][1]){ result++; } else points[i][1]=min(points[i][1], points[i-1][1]); } return result; }}; 435. 无重叠区间https://leetcode.cn/problems/non-overlapping-intervals/ 本题和上题思路差不多，返回移除区间的最小数量，使剩余区间互不重叠。那么上题的result就代表不重叠的区间数，将总区间减去result就是需要移除的重叠区间数。 123456789101112131415161718class Solution {public: static bool cmp(const vector&lt;int&gt;&amp; a,const vector&lt;int&gt;&amp; b){ return a[0]&lt;b[0]; } int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if(intervals.size()==0) return 0; int result=1; //不重叠数 sort(intervals.begin(),intervals.end(),cmp); for(int i=1;i&lt;intervals.size();i++){ if(intervals[i][0]&gt;=intervals[i-1][1]){ //这个题区间取等的话不重叠，气球那道题区间不能取等 result++; } else intervals[i][1]=min(intervals[i][1], intervals[i-1][1]); } return intervals.size()-result; }}; 763.划分字母区间https://leetcode.cn/problems/partition-labels/ 本题我的方法思想是用map数组记录每一个字母出现的最后的位置，所切割的数组一定要遍历到这个字母的最后出现位置才能切割，保证同一字母最多出现在一个片段中。也就是： 统计每一个字符最后出现的位置 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; partitionLabels(string s) { unordered_map&lt;char,int&gt; m; vector&lt;int&gt; result; for(int i=0;i&lt;s.size();i++){ m[s[i]]=i; //记录每个字母最后出现的位置 } int end=0; int start=0; for(int i=0;i&lt;s.size();i++){ end=max(end,m[s[i]]); if(i==end){ result.push_back(end-start+1); start=i+1; } } return result; }}; 56. 合并区间https://leetcode.cn/problems/merge-intervals/ 和前面几题重叠区间类似，所以一样的套路，先排序，让所有的相邻区间尽可能的重叠在一起 按照左边界从小到大排序之后，如果 intervals[i][0] &lt;= intervals[i - 1][1] 即intervals[i]的左边界 &lt;= intervals[i - 1]的右边界，则一定有重叠。（本题相邻区间也算重贴，所以是&lt;=） 如果有重叠，更新intervals[i]，让其为两个重叠区间最大边界， 起始放入intervals[0]，每次遍历放入intervals[i]，如果遇见重叠区间则pop掉上一次区间，更新给更大区间。 12345678910111213141516171819202122class Solution {public: static bool cmp(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b){ return a[0]&lt;b[0]; } vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if(intervals.size()==1) return intervals; vector&lt;vector&lt;int&gt;&gt; result; sort(intervals.begin(),intervals.end(),cmp); result.push_back(intervals[0]); for(int i=1;i&lt;intervals.size();i++){ if(intervals[i][0]&lt;=intervals[i-1][1]){ intervals[i][1]=max(intervals[i][1],intervals[i-1][1]); intervals[i][0]=min(intervals[i][0],intervals[i-1][0]); result.pop_back(); } result.push_back(intervals[i]); } return result; }}; 738. 单调递增的数字https://leetcode.cn/problems/monotone-increasing-digits/ 贪心算法 题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。 例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。 这一点如果想清楚了，这道题就好办了。 此时是从前向后遍历还是从后向前遍历呢？ 从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。 这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。 那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299 确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。 12345678910111213141516171819class Solution {public: int monotoneIncreasingDigits(int N) { string strNum = to_string(N); // flag用来标记赋值9从哪里开始 // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行 int flag = strNum.size(); for (int i = strNum.size() - 1; i &gt; 0; i--) { if (strNum[i - 1] &gt; strNum[i] ) { flag = i; strNum[i - 1]--; } } for (int i = flag; i &lt; strNum.size(); i++) { strNum[i] = '9'; } return stoi(strNum); }}; 贪心算法总结https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.html 动态规划https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html 对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！ 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 509. 斐波那契数https://leetcode.cn/problems/fibonacci-number/ 动规五部曲 这里我们要用一个一维dp数组来保存递归的结果 1.确定dp数组以及下标的含义 dp[i]的定义为：第i个数的斐波那契数值是dp[i] 2.确定递推公式 因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]; 3.dp数组如何初始化题目中把如何初始化也直接给我们了，如下： dp[0] = 0; dp[1] = 1; 4.确定遍历顺序 从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的 5.举例推导dp数组 按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列： 0 1 1 2 3 5 8 13 21 34 55 12345678910111213class Solution {public: int fib(int N) { if (N &lt;= 1) return N; vector&lt;int&gt; dp(N + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[N]; }}; 70. 爬楼梯https://leetcode.cn/problems/climbing-stairs/ 动规五部曲 定义一个一维数组来记录不同楼层的状态 确定dp数组以及下标的含义dp[i]： 爬到第i层楼梯，有dp[i]种方法 确定递推公式 如何可以推出dp[i]呢？ 从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。 首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。 还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。 那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！ 所以dp[i] = dp[i - 1] + dp[i - 2] 。 在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。 这体现出确定dp数组以及下标的含义的重要性！ dp数组如何初始化 再回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]种方法。 不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。 确定遍历顺序从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的 举例推导dp数组举例当n为5的时候，dp table（dp数组）就是斐波那契数列 12345678910111213class Solution {public: int climbStairs(int n) { if (n &lt;= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针 vector&lt;int&gt; dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) { // 注意i是从3开始的 dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }}; 746. 使用最小花费爬楼梯https://leetcode.cn/problems/min-cost-climbing-stairs/ 动态规划五部曲 确定dp数组以及下标的含义使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。 dp[i]的定义：到达第i台阶所花费的最少钱为dp[i]。 确定递推公式 可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。 dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。 dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。 那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？ 一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); dp数组如何初始化 新题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。 所以初始化 dp[0] = 0，dp[1] = 0; 确定遍历顺序最后一步，递归公式有了，初始化有了，如何遍历呢？ 因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。 举例推导dp数组 123456789101112class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; dp(cost.size() + 1); dp[0] = 0; // 默认第一步都是不花费体力的 dp[1] = 0; for (int i = 2; i &lt;= cost.size(); i++) { dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[cost.size()]; }}; 62.不同路径https://leetcode.cn/problems/unique-paths/ 动规五部曲来分析： 确定dp数组（dp table）以及下标的含义dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。 确定递推公式 想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。 此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。 那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。 dp数组的初始化如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。 所以初始化代码为： for (int i = 0; i &lt; m; i++) dp[i][0] = 1; for (int j = 0; j &lt; n; j++) dp[0][j] = 1; 确定遍历顺序这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。 这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。 举例推导dp数组 1234567891011121314class Solution {public: int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) dp[i][0] = 1; for (int j = 0; j &lt; n; j++) dp[0][j] = 1; for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }}; 63. 不同路径 IIhttps://leetcode.cn/problems/unique-paths-ii/ 动规五部曲： 确定dp数组（dp table）以及下标的含义dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。 确定递推公式 递推公式和62.不同路径一样，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]。 但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。 dp数组初始化 因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理。 但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0。 注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理 从递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值。 举例推导dp数组 12345678910111213141516171819class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0 return 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j] == 1) continue; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }}; 01背包理论基础https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html 二维数组 确定dp数组以及下标的含义:dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少 递推公式:不放物品i：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。 放物品i：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp数组如何初始化 只需初始化dp[0][j] 和 dp[i][0] 确定遍历顺序先遍历背包，再遍历物品，也是可以的，因为dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。所以两种遍历都能提前得到这两个地方的值。 一维数组 确定dp数组的定义 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]为 容量为j的背包所背的最大价值。 dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 [j - 物品i重量] 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值， 所以递归公式为： dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 一维dp数组如何初始化 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 一维dp数组遍历顺序 倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次 12345 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 416. 分割等和子集https://leetcode.cn/problems/partition-equal-subset-sum/ 确定dp数组以及下标的含义 01背包中，dp[j] 表示： 容量（所能装的重量）为j的背包，所背的物品价值最大可以为dp[j]。 如果背包所载重量为target， dp[target]就是装满 背包之后的总价值，因为 本题中每一个元素的数值既是重量，也是价值，所以，当 dp[target] == target 的时候，背包就装满了。 确定递推公式 01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。 所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); dp数组如何初始化 在01背包，一维dp如何初始化，已经讲过， 从dp[j]的定义来看，首先dp[0]一定是0。 如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。 确定遍历顺序如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！ 12345678910111213141516171819class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(10001,0); int sum=0; for(int i=0;i&lt;nums.size();i++){ sum+=nums[i]; } if(sum%2==1) return false; int target=sum/2; for(int i=0;i&lt;nums.size();i++){ for(int j=target;j&gt;=nums[i];j--){ dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]); } } if(dp[target]==target) return true; return false; }}; 1049. 最后一块石头的重量 IIhttps://leetcode.cn/problems/last-stone-weight-ii/ 本题其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。 一堆的石头重量是sum，那么我们就尽可能拼成 重量为 sum / 2 的石头堆。 这样剩下的石头堆也是 尽可能接近 sum/2 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum / 2的背包。 看到这里，大家是否感觉和昨天讲解的 416. 分割等和子集 (opens new window)非常像了，简直就是同一道题。416. 分割等和子集 (opens new window)是求背包是否正好装满，而本题是求背包最多能装多少。 1234567891011121314151617class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { vector&lt;int&gt; dp(1501,0); int sum=0; for(int i=0;i&lt;stones.size();i++){ sum+=stones[i]; } int target=sum/2; for(int i=0;i&lt;stones.size();i++){ for(int j=target;j&gt;=stones[i];j--){ dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]); } } return sum-2*dp[target]; }}; 494.目标和https://leetcode.cn/problems/target-sum/ 假设加法的总和为x，那么减法对应的总和就是sum - x。 所以我们要求的是 x - (sum - x) = target x = (target + sum) / 2 因此，问题等价于：从nums中选子集，使其和为x，这样的子集有多少个？ dp 数组的定义定义dp[j]表示：从数组中选取元素，能组成和为j的子集的数量。 确定递推公式 不选nums[i]：组成和为j的子集数量不变，即保持dp[j]的原有值。 选nums[i]：若选nums[i]，则需要先有一个和为j - nums[i]的子集（加上nums[i]后总和为j） 递推公式dp[j] = dp[j] + dp[j - nums[i]] dp数组如何初始化这里dp[0] 同样初始为1 ,即装满背包为0的方法有一种，放0件物品,即子集为一个空集。 确定遍历顺序之前系统讲过对于01背包问题一维dp的遍历。 遍历物品放在外循环，遍历背包在内循环，且内循环倒序（为了保证物品只使用一次） 12345678910111213141516171819class Solution {public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) { int sum=0; for(int i=0;i&lt;nums.size();i++){ sum+=nums[i]; } if((target+sum)%2==1||abs(target)&gt;sum) return 0; //加法总和X一定是整数 int T=(target+sum)/2; vector&lt;int&gt; dp(T+1,0); dp[0]=1; for(int i=0;i&lt;nums.size();i++){ for(int j=T;j&gt;=nums[i];j--){ dp[j]+=dp[j-nums[i]]; } } return dp[T]; }}; 474.一和零https://leetcode.cn/problems/ones-and-zeroes/二维 0-1 背包问题 相当于每个物有两个重量限制 确定dp数组（dp table）以及下标的含义dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j] 确定递推公式 dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。 dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。 然后我们在遍历的过程中，取dp[i][j]的最大值。 所以递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); 此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。 这就是一个典型的01背包！ 只不过物品的重量有了两个维度而已。 dp数组如何初始化因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖 确定遍历顺序 我们讲到了01背包为什么一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！ 那么本题也是，物品就是strs里的字符串，背包容量就是题目描述中的m和n。 12345678910111213141516171819class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); // 默认初始化0 for (string str : strs) { // 遍历物品 int oneNum = 0, zeroNum = 0; for (char c : str) { if (c == '0') zeroNum++; else oneNum++; } for (int i = m; i &gt;= zeroNum; i--) { // 遍历背包容量且从后向前遍历！ for (int j = n; j &gt;= oneNum; j--) { dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } } } return dp[m][n]; }}; 完全背包二维https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html 一维https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4.html 外层for遍历背包，内层for循环遍历物品 123456for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl;} 先遍历物品再遍历背包： 12345for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 518.零钱兑换IIhttps://leetcode.cn/problems/coin-change-ii/ 确定dp数组以及下标的含义dp[j]：凑成总金额j的货币组合数为dp[j] 确定递推公式求装满背包有几种方法，公式都是：dp[j] += dp[j - nums[i]] dp数组如何初始化装满背包容量为0 的方法是1，即不放任何物品，dp[0] = 1 确定遍历顺序外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）,这种遍历顺序中dp[j]里计算的是组合数如果循环颠倒，dp[j]里算出来的就是排列数。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 12345678910111213class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { vector&lt;uint64_t&gt; dp(amount + 1, 0); // 防止相加数据超int dp[0] = 1; // 只有一种方式达到0 for (int i = 0; i &lt; coins.size(); i++) { // 遍历物品 for (int j = coins[i]; j &lt;= amount; j++) { // 遍历背包 dp[j] += dp[j - coins[i]]; } } return dp[amount]; // 返回组合数 }}; 377. 组合总和 Ⅳhttps://leetcode.cn/problems/combination-sum-iv/ 个数可以不限使用，说明这是一个完全背包本题要求的是排列，那么这个for循环嵌套的顺序就是外层for遍历背包，内层for循环遍历物品其他思路和上一题一样。 12345678910111213class Solution {public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { vector&lt;uint64_t&gt; dp(target+1,0); dp[0]=1; for(int i=0;i&lt;=target;i++){ for(int j=0;j&lt;nums.size();j++){ if(i&gt;=nums[j]) dp[i]+=dp[i-nums[j]]; } } return dp[target]; }}; 322. 零钱兑换https://leetcode.cn/problems/coin-change/ 确定dp数组以及下标的含义dp[j]：凑足总额为j所需钱币的最少个数为dp[j] 确定递推公式 凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j] 所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。 递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]) dp数组如何初始化首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0; 确定遍历顺序本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数,两种循环都行 1234567891011121314class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { vector&lt;uint64_t&gt; dp(amount+1,INT_MAX); dp[0]=0; for(int i=0;i&lt;coins.size();i++){ for(int j=0;j&lt;=amount;j++){ if(j&gt;=coins[i]) dp[j]=min(dp[j],dp[j-coins[i]]+1); } } if(dp[amount]==INT_MAX) return -1; return dp[amount]; }}; 279.完全平方数和上一题思路差不多，唯一变动是想一想物品怎么去定义，转化为背包问题https://leetcode.cn/problems/perfect-squares/ dp[j]：和为j的完全平方数的最少数量为dp[j] 12345678910111213class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n+1,INT_MAX); dp[0]=0; for(int i=1;i*i&lt;=n;i++){ for(int j=0;j&lt;=n;j++){ if(j&gt;=i*i) dp[j]=min(dp[j],dp[j-i*i]+1); } } return dp[n]; }}; 139.单词拆分https://leetcode.cn/problems/word-break/ 确定dp数组以及下标的含义dp[i] 表示：字符串s的前i个字符（即子串s[0..i-1]）能否被拆分成字典中的单词。 确定递推公式 对于每个长度i（从 1 到s的长度），我们需要检查：是否存在一个拆分点j（0 ≤ j &lt; i），使得： 子串s[j..i-1]（即从j开始，长度为i-j的子串）是字典中的单词； 前j个字符能被拆分（即dp[j] = true）。 如果存在这样的j，并且dp[j]也为true，则代表前后的字符串都能被拆分，则dp[i] = true（前i个字符能被拆分）。 初始化dp[0]=true 循环方式排列问题，先遍历背包再遍历物品 123456789101112131415161718192021222324bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { // 1. 把字典转为哈希集合，加速单词查找（O(1)时间复杂度） unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); // 2. 定义dp数组：dp[i]表示前i个字符能否被拆分 vector&lt;bool&gt; dp(s.size() + 1, false); dp[0] = true; // 初始化：空串可拆分 // 3. 排列问题有顺序 先遍历背包，外层循环：遍历背包容量（前i个字符） for (int i = 1; i &lt;= s.size(); i++) { // 4. 内层循环：遍历物品，拆分点j（0到i-1） for (int j = 0; j &lt; i; j++) { // 截取子串s[j..i-1]（从j开始，长度i-j） string word = s.substr(j, i - j); // 若子串在字典中，且前j个字符可拆分，则前i个字符可拆分 if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]==true) { dp[i] = true; } } } // 最终结果：整个字符串能否被拆分 return dp[s.size()];} 背包问题总结https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html 背包递推公式 问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) 装满背包有几种方法：dp[j] += dp[j - nums[i]] 问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); 01背包 二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。 一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。 完全背包 一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品 198.打家劫舍https://leetcode.cn/problems/house-robber/ 确定dp数组（dp table）以及下标的含义dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。 确定递推公式 决定dp[i]的因素就是第i房间偷还是不偷。 如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。 如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点） 然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); dp数组如何初始化 从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1] 从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]); 确定遍历顺序dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 1234567891011121314class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.size() - 1]; }}; 或者dp[i]代表前i个房子最大金额 123456789101112131415class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { //dp[i]前i个房子最大金额 vector&lt;int&gt; dp(nums.size()+1,0); if(nums.size()==1) return nums[0]; dp[0]=0; dp[1]=nums[0]; dp[2]=max(nums[1],nums[0]); for(int i=2;i&lt;=nums.size();i++){ dp[i]=max(dp[i-1],dp[i-2]+nums[i-1]); } return dp[nums.size()]; }}; 213.打家劫舍IIhttps://leetcode.cn/problems/house-robber-ii/ 环形数组拆成(start,end-1)和（start+1，end）来考虑 1234567891011121314151617181920212223class Solution {public: int subrob(vector&lt;int&gt;&amp; subnums) { //前下标为i的房屋的总价值； if(subnums.size()==1) return subnums[0]; vector&lt;int&gt; dp(subnums.size(),0); dp[0]=subnums[0]; dp[1]=max(subnums[0],subnums[1]); for(int i=2;i&lt;subnums.size();i++){ dp[i]=max(dp[i-1],dp[i-2]+subnums[i]); } return dp[subnums.size()-1]; } int rob(vector&lt;int&gt;&amp; nums) { if(nums.size()==1) return nums[0]; vector&lt;int&gt; subnums1(nums.begin(),nums.end()-1); vector&lt;int&gt; subnums2(nums.begin()+1,nums.end()); int dp1=subrob(subnums1); int dp2=subrob(subnums2); return max(dp1,dp2); }}; 337.打家劫舍 IIIhttps://leetcode.cn/problems/house-robber-iii/ 确定递归函数的参数和返回值这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。 所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱 确定终止条件在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回这也相当于dp数组的初始化 确定遍历顺序 首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。 通过递归左节点，得到左节点偷与不偷的金钱。 通过递归右节点，得到右节点偷与不偷的金钱。 确定单层递归的逻辑 如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-&gt;val + left[0] + right[0]; （如果对下标含义不理解就再回顾一下dp数组的含义） 如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]); 最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱} 123456789101112131415161718class Solution {public: int rob(TreeNode* root) { vector&lt;int&gt; result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector&lt;int&gt; robTree(TreeNode* cur) { if (cur == NULL) return vector&lt;int&gt;{0, 0}; vector&lt;int&gt; left = robTree(cur-&gt;left); vector&lt;int&gt; right = robTree(cur-&gt;right); // 偷cur，那么就不能偷左右节点。 int val1 = cur-&gt;val + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; }}; 121. 买卖股票的最佳时机https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/双重for循环会超时 贪心因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。 123456789101112class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int low = INT_MAX; int result = 0; for (int i = 0; i &lt; prices.size(); i++) { low = min(low, prices[i]); // 取最左最小价格 result = max(result, prices[i] - low); // 直接取最大区间利润 } return result; }}; 123.买卖股票的最佳时机IIIhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/ 确定dp数组以及下标的含义 一天一共就有五个状态， 没有操作 （其实我们也可以不设置这个状态） 第一次持有股票 第一次不持有股票 第二次持有股票 第二次不持有股票 dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金 确定递推公式 达到dp[i][1]状态，有两个具体操作： 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i] 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1] 那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？ 一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]); 同理dp[i][2]也有两个操作： 操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i] 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2] 所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]) 同理可推出剩下状态部分： dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); dp数组如何初始化 第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0; 第0天做第一次买入的操作，dp[0][1] = -prices[0]; 第0天做第一次卖出的操作，这个初始值应该是多少呢？ 此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0][2] = 0; 第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？ 第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。 所以第二次买入操作，初始化为：dp[0][3] = -prices[0]; 同理第二次卖出初始化dp[0][4] = 0; 确定遍历顺序从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。 123456789101112131415161718192021222324252627class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; //dp[i][j]表示第i天状态j所剩最大现金 //0:没有操作 //1:第一次买入股票 //2:第一次卖出股票 //3:第二次买入股票 //4:第二次卖出股票 vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(5, 0)); dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = dp[i - 1][0]; //操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i] //操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1] dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); //操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i] //操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2] dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); } return dp[prices.size() - 1][4]; }}; 188.买卖股票的最佳时机IVhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/ 和123思路差不多，把最大交易次数换成了k，所以总交易状态为2*k 用j代表第几次买入还是卖出状态，j为奇数就是买入，偶数就是卖出 当交易次数无限时，只需定义两种状态。只需跟踪 “是否持有股票”，两种状态即可覆盖所有情况，“不买也不卖” 被包含在 “不持有” 中。 当交易次数有限时，需要定义三种状态，必须跟踪 “已完成多少笔交易”+“当前是否持有”，因此需要细分状态，其中 “不买也不卖” 是初始基准状态，用于准确计算交易次数。 123456789101112131415161718192021222324252627282930class Solution {public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; //dp[i][j]表示第i天 状态j 所剩最大现金 vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2*k+1, 0)); //j:奇数买入，偶数卖出 for (int i = 1; i &lt; prices.size(); i++) { for(int j=2;j&lt;=2*k;j=j+2){ //初始化 dp[0][j-1] = -prices[0]; //状态1 最开始没买过 dp[i][0] = dp[i - 1][0]; //状态2 买入股票 //操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i] //操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1] dp[i][j-1] = max(dp[i - 1][j-1], dp[i - 1][j-2] - prices[i]); //状态3 卖出股票 //操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i] //操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2] dp[i][j] = max(dp[i - 1][j], dp[i - 1][j-1] + prices[i]); } } return dp[prices.size() - 1][2*k]; }}; 309.最佳买卖股票时机含冷冻期https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/ dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j] 由于可以无限次交易，所以只定义两个维度，第一个维度是天数 第二个维度表示状态， 0代表持有(不冷却)，1代表不持有(不冷却)，2代表不持有(冷却) 12345678910111213141516class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.size() == 0) return 0; // 由于可以无限次交易，所以只定义两个维度，第一个维度是天数 // 第二个维度表示是否持有股票， 0代表持有(不冷却)，1代表不持有(不冷却)，2代表不持有(冷却) vector&lt;vector&lt;int&gt;&gt; dp(prices.size(),vector&lt;int&gt;(3,0)); dp[0][0]=-prices[0]; for(int i=1;i&lt;prices.size();i++){ dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]); dp[i][1]=max(dp[i-1][1],dp[i-1][2]); dp[i][2]=dp[i-1][0]+prices[i]; } return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]); }}; 714.买卖股票的最佳时机含手续费https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ 无限交易，两种状态，持有和不持有dp[i][0] 表示第i天持有股票所得最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金 12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { //0代表持有股票，1代表不持有股票 所剩最大现金 vector&lt;vector&lt;int&gt;&gt; dp(prices.size(),vector&lt;int&gt;(2,0)); dp[0][0]=-prices[0]; for(int i=1;i&lt;prices.size();i++){ dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]); dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]-fee); } return max(dp[prices.size()-1][1],dp[prices.size()-1][0]); }}; 股票问题总结https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html 674. 最长连续递增序列https://leetcode.cn/problems/longest-continuous-increasing-subsequence/ 这道题目也可以用贪心来做，也就是遇到nums[i] &gt; nums[i - 1]的情况，count就++，否则count为1，记录count的最大值就可以了。 123456789101112131415class Solution {public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) { int result=1; int count=1; for(int i=1;i&lt;nums.size();i++){ if(nums[i]&gt;nums[i-1]) { count++; } else count=1; if(count&gt;result) result=count; } return result; }}; 300.最长递增子序列https://leetcode.cn/problems/longest-increasing-subsequence/ dp[i]的定义 本题中，正确定义dp数组的含义十分重要。 dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度 状态转移方程 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。 所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); 注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值。 dp[i]的初始化 每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1. 因为要遍历所有子序列，要用双重for循环 123456789101112131415class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size(),1); //dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度 int result=1; for(int i=1;i&lt;nums.size();i++){ for(int j=0;j&lt;i;j++){ if(nums[i]&gt;nums[j]) dp[i]=max(dp[j]+1,dp[i]); } if(dp[i]&gt;result) result=dp[i]; } return result; }}; 718. 最长重复子数组因为是子数组所以是连续的https://leetcode.cn/problems/maximum-length-of-repeated-subarray/ 确定dp数组（dp table）以及下标的含义dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 （特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ） 定递推公式根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。 dp数组如何初始化根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！ 但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] = dp[i - 1][j - 1] + 1; 所以dp[i][0] 和dp[0][j]初始化为0 12345678910111213141516class Solution {public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp (nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1, 0)); int result = 0; for (int i = 1; i &lt;= nums1.size(); i++) { for (int j = 1; j &lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } if (dp[i][j] &gt; result) result = dp[i][j]; } } return result; }}; 1143.最长公共子序列https://leetcode.cn/problems/longest-common-subsequence/ 确定dp数组（dp table）以及下标的含义dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j] 确定递推公式 主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1; 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。 即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); dp数组如何初始化 先看看dp[i][0]应该是多少呢？ text1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0; 同理dp[0][j]也是0。 那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。 1234567891011121314151617class Solution {public: int longestCommonSubsequence(string text1, string text2) { vector&lt;vector&lt;int&gt;&gt; dp(text1.size()+1,vector&lt;int&gt;(text2.size()+1,0)); int result=0; for(int i=1;i&lt;=text1.size();i++){ for(int j=1;j&lt;=text2.size();j++){ if(text1[i-1]==text2[j-1]){ dp[i][j]=dp[i-1][j-1]+1; } else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); result=max(result,dp[i][j]); } } return result; }}; 1035.不相交的线https://leetcode.cn/problems/uncrossed-lines/ 和上一题基本上一模一样 12345678910111213141516class Solution {public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp(nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1, 0)); for (int i = 1; i &lt;= nums1.size(); i++) { for (int j = 1; j &lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[nums1.size()][nums2.size()]; }}; 53. 最大子序和贪心做过一遍，这一次用dp做https://leetcode.cn/problems/maximum-subarray/ 确定dp数组（dp table）以及下标的含义dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i] 确定递推公式 dp[i]只有两个方向可以推出来： dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和 nums[i]，即：从头开始计算当前连续子序列和 一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]); dp数组如何初始化 从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。 dp[0]应该是多少呢? 根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。 确定遍历顺序递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。 12345678910111213class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size(),0); int result=nums[0]; dp[0]=nums[0]; for(int i=1;i&lt;nums.size();i++){ dp[i]=max(dp[i-1]+nums[i],nums[i]); result=max(result,dp[i]); } return result; }}; 392.判断子序列https://leetcode.cn/problems/is-subsequence/ 和最长公共子序列思路差不多，加一步判断长度是否和子序列相等就行 1234567891011121314151617class Solution {public: bool isSubsequence(string s, string t) { vector&lt;vector&lt;int&gt;&gt; dp(s.size()+1,vector&lt;int&gt;(t.size()+1,0)); int result=0; for(int i=1;i&lt;=s.size();i++){ for(int j=1;j&lt;=t.size();j++){ if(s[i-1]==t[j-1]){ dp[i][j]=dp[i-1][j-1]+1; } else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); result=max(result,dp[i][j]); } } return result==s.size()?true:false; }}; 115.不同的子序列https://leetcode.cn/problems/distinct-subsequences/ 1.dp[i][j]定义dp[i][j] 为在s的前i个元素(即s[0, i - 1])中，有多少个t[0, j - 1]的匹配(以t[j - 1]为结尾) 2 确定递推公式假设 t=”bag”,s为”babga” 两种转移情况分别为: 如果s增加了g变成”babgag” 当此元素相等时, 则求s的前面有多少个”ba” + 前面有多少个完整”bag”即 dp[ i-1 ][ j-1 ]+dp[ i-1 ][ j ] 若此元素不相等, 则求s的前面有多少个”bag”即 dp[ i-1 ][ j ]所以递推公式为: 123456789for (int i = 1; i &lt;= s.size(); i++) { for (int j = 1; j &lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j]; } }} 3 dp数组如何初始化从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][j] 是从上方和左上方推导而来，那么 dp[i][0] 和dp[0][j]是一定要初始化的dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数那么dp[i][0]一定都是1，dp[0][j]一定都是0,dp[0][0]为1 123vector&lt;vector&lt;long long&gt;&gt; dp(s.size() + 1, vector&lt;long long&gt;(t.size() + 1));for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 1;for (int j = 1; j &lt;= t.size(); j++) dp[0][j] = 0; 4 循环顺序，子序列放内层循环，长序列放外层循环 但是子序列也可以大于长序列，不能用result返回最大值，因为result记录的是中间状态的最大值，但题目要求的是 “s完整包含t完整的子序列数量”，必须用dp[s.length][t.length]作为结果。 代码如下: 1234567891011121314151617class Solution {public: int numDistinct(string s, string t) { vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size()+1,vector&lt;uint64_t&gt;(t.size()+1)); for(int i=0;i&lt;=s.size();i++) dp[i][0]=1; for(int j=1;j&lt;=t.size();j++) dp[0][j]=0; for(int i=1;i&lt;=s.size();i++){ for(int j=1;j&lt;=t.size();j++){ if(s[i-1]==t[j-1]){ dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; } else dp[i][j]=dp[i-1][j]; } } return dp[s.size()][t.size()]; }}; 583. 两个字符串的删除操作https://leetcode.cn/problems/delete-operation-for-two-strings/ 其实就是求最长公共子序列。只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，两个字符串长度和减去二倍的公共子序列长度就是答案 1234567891011121314151617class Solution {public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1,0)); int result=0; for(int i=1;i&lt;=word1.size();i++){ for(int j=1;j&lt;=word2.size();j++){ if(word1[i-1]==word2[j-1]){ dp[i][j]=dp[i-1][j-1]+1; } else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); result=max(dp[i][j],result); } } return word1.size()+word2.size()-2*result; }}; 72. 编辑距离https://leetcode.cn/problems/edit-distance/ 确定dp数组（dp table）以及下标的含义dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j] 确定递推公式if (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j] 就应该是 dp[i - 1][j - 1]，即dp[i][j] = dp[i - 1][j - 1]; if (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？ 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。即 dp[i][j] = dp[i - 1][j] + 1; 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。即 dp[i][j] = dp[i][j - 1] + 1; 这里有同学发现了，怎么都是删除元素，添加元素去哪了。 word2添加一个元素，相当于word1删除一个元素，例如 word1 = “ad” ，word2 = “a”，word1删除元素’d’ 和 word2添加一个元素’d’，变成word1=”a”, word2=”ad”， 最终的操作数是一样！ 操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。 可以回顾一下，if (word1[i - 1] == word2[j - 1])的时候我们的操作 是 dp[i][j] = dp[i - 1][j - 1] 对吧。 那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。 所以 dp[i][j] = dp[i - 1][j - 1] + 1; 综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; dp数组如何初始化再回顾一下dp[i][j]的定义： dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。 那么dp[i][0] 和 dp[0][j] 表示什么呢？ dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。 那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i; 同理dp[0][j] = j; 确定遍历顺序从如下四个递推公式： dp[i][j] = dp[i - 1][j - 1] dp[i][j] = dp[i - 1][j - 1] + 1 dp[i][j] = dp[i][j - 1] + 1 dp[i][j] = dp[i - 1][j] + 1 可以看出dp[i][j]是依赖左方，上方和左上方元素的 所以在dp矩阵中一定是从左到右从上到下去遍历。 1234567891011121314151617class Solution {public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1,0)); for(int i=0;i&lt;=word1.size();i++) dp[i][0]=i; for(int j=0;j&lt;=word2.size();j++) dp[0][j]=j; for(int i=1;i&lt;=word1.size();i++){ for(int j=1;j&lt;=word2.size();j++){ if(word1[i-1]==word2[j-1]){ dp[i][j]=dp[i-1][j-1]; } else dp[i][j]=min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]})+1; } } return dp[word1.size()][word2.size()]; }}; 编辑距离小结https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html","link":"/2025/10/03/Data%20Structure%20and%20Algorithms/"}],"tags":[],"categories":[],"pages":[]}