{"posts":[{"title":"Leetcode学习","text":"欢迎来到我的cpp代码学习网站 学习内容参考见 “代码随想录” https://programmercarl.com/ 一、数据结构与算法哈希表常见三种结构 数组 set map在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可重复 能否改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(log n) O(log n) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值（或key）是否可重复 能否更改数值（或key） 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(log n) O(log n) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 STL容器和容器适配器一些基本语法表格1：非STL容器（STL容器适配器） 具体容器 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 栈（stack） push(val)：仅从「栈顶」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「栈顶」元素（无返回值，需用top()获取栈顶值后再删） ❌ 不支持push_back/pop_back；仅支持栈顶操作（LIFO），无迭代器访问 队列（queue） push(val)：仅从「队尾」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「队首」元素（无返回值，需用front()获取队首值后再删） ❌ 不支持push_back/pop_front；仅支持队尾插、队首删（FIFO），无迭代器访问 优先级队列（priority_queue） push(val)：插入元素后自动按优先级排序（底层用vector+堆实现，对外统一用push） pop()：仅删除「优先级最高的元素」（堆顶，无返回值，需用top()获取后再删） ❌ 不支持push_back/pop_back；无顺序概念，仅按优先级操作，无迭代器访问 表格2：STL容器（含关联/非关联区分） 具体容器 STL容器类型（关联/非关联） 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 动态数组（vector） 非关联（序列容器） 1. push_back(val)：从「尾部」插入（唯一的push类接口，无push_front）2. insert(iter, val)：在指定迭代器位置插入 1. pop_back()：删除「尾部」元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间元素 ❌ 不支持push_front（头部插入效率极低）；仅尾部支持push_back/pop_back，指定位置用insert/erase 双向队列（deque） 非关联（序列容器） 1. push_back(val)：从「队尾」插入2. push_front(val)：从「队首」插入 1. pop_back()：删除「队尾」元素2. pop_front()：删除「队首」元素3. erase(iter)：删除指定迭代器位置元素 ✅ 同时支持push_back/push_front（区别于vector）；可随机访问（用[]下标），适合两端频繁操作 集合（set） 关联（有序唯一集合） insert(val)：按红黑树排序插入（无push/push_back，因按「键」有序存储，非位置存储） 1. erase(key)：按元素值删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 完全不支持push/push_back；元素有序且唯一，按值操作而非位置 多重集合（multiset） 关联（有序可重复集合） insert(val)：按红黑树排序插入（无push/push_back，支持重复值插入） 1. erase(key)：删除所有等于key的元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；元素有序可重复，按值删除时需注意是否删除所有匹配项 映射（map） 关联（有序唯一键值对） 1. insert(pair&lt;key, val&gt;)：按key排序插入2. map[key] = val：直接赋值（不存在则插入，存在则修改） 1. erase(key)：按key删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；存储键值对（key唯一），[]操作符可插入/修改值 多重映射（multimap） 关联（有序可重复键值对） insert(pair&lt;key, val&gt;)：按key排序插入（支持重复key插入，无[]操作符） 1. erase(key)：删除所有key匹配的键值对2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back、无[]操作符；key可重复，需用find()/equal_range()获取指定key的元素 所有STL算法（包括sort, reverse等）都严格遵循左闭右开区间的约定，例如反转中没有对下标 i 对应的数值进行反转操作 1reverse(s.begin() , s.begin() + i); 二叉树基础知识 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。 刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。 123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; 深度优先遍历o 前序遍历（递归法，迭代法）o中序遍历（递归法，迭代法）o后序遍历（递归法，迭代法） 广度优先遍历o层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 下面给出前序遍历C++代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 下面是层序遍历C++代码： 12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; }}; 110.平衡二叉树力扣链接：https://leetcode.cn/problems/balanced-binary-tree 平衡二叉树定义：一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 注意二叉树高度和深度的区别 递归三步曲分析：1.明确递归函数的参数和返回值参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。2.明确终止条件递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为03.明确单层递归的逻辑如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。代码如下： 1234567891011121314class Solution {public: int getheight(TreeNode* node){ if(node==NULL) return 0; int leftheight=getheight(node-&gt;left); if(leftheight==-1) return -1; int rightheight=getheight(node-&gt;right); if(rightheight==-1) return -1; return abs(leftheight-rightheight)&gt;1?-1:max(leftheight,rightheight)+1; } bool isBalanced(TreeNode* root) { return getheight(root)!=-1?true:false; }}; 257.二叉树的所有路径力扣链接：https://leetcode.cn/problems/binary-tree-paths 递归1.递归函数参数以及返回值要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值。 1void traversal(TreeNode* node, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) 2.考虑递归终止条件找到叶子节点代表一条路径结束, 123if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { 终止处理逻辑} 为什么没有判断cur是否为空呢，因为上面的逻辑可以控制空节点不入循环。接下来再来看一下终止处理的逻辑。这里我们先使用vector结构的path容器来记录路径，最终转化成字符串存入题目要求的结果容器中，代码如下： 12345678910if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { // 遇到叶子节点 string sPath; for (int i = 0; i &lt; path.size() - 1; i++) { // 将path里记录的路径转为string格式 sPath += to_string(path[i]); sPath += &quot;-&gt;&quot;; } sPath += to_string(path[path.size() - 1]); // 记录最后一个节点（叶子节点） result.push_back(sPath); // 收集一个路径 return;} 3.确定单层递归逻辑在走完一条路径后回溯到上一个节点，回溯和递归是一一对应的，有一个递归，就要有一个回溯都在花括号里面。 12345678if (node-&gt;left) { traversal(cur-&gt;left, path, result); path.pop_back(); // 回溯}if (node-&gt;right) { traversal(cur-&gt;right, path, result); path.pop_back(); // 回溯} 最终代码如下: 12345678910111213141516171819202122232425262728293031class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; path,vector&lt;string&gt;&amp; result){ path.push_back(node-&gt;val); if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { string spath; for(int i=0;i&lt;path.size()-1;i++){ spath+=to_string(path[i]); spath+=&quot;-&gt;&quot;; } spath+=to_string(path[path.size()-1]); result.push_back(spath); return; } if(node-&gt;left!=NULL){ traversal(node-&gt;left,path,result); path.pop_back(); } if(node-&gt;right!=NULL){ traversal(node-&gt;right,path,result); path.pop_back(); } } vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;int&gt; path; vector&lt;string&gt; result; if(root==NULL) return result; traversal(root,path,result); return result; }}; 这个题不太好理解，可以多巩固下。 404.左叶子之和力扣题目链接：https://leetcode.cn/problems/sum-of-left-leaves 递归：递归的遍历顺序为后序遍历（左右中） 1.确定递归函数的参数和返回值判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int2.确定终止条件如果遍历到空节点，那么左叶子值一定是03.确定单层递归的逻辑当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。代码如下: 1234567891011121314151617181920class Solution {public: int sumOfLeftLeaves(TreeNode* root) { if (root == NULL) return 0; // 单层逻辑 int leftValue = 0; // 检查当前节点的左孩子是否是左叶子 if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { leftValue = root-&gt;left-&gt;val; // 是左叶子，记录值 } else { leftValue = sumOfLeftLeaves(root-&gt;left); // 不是，递归求左子树的左叶子和 } // 递归求右子树的左叶子和（右子树的左叶子也是当前树的左叶子） int rightValue = sumOfLeftLeaves(root-&gt;right); // 当前树的左叶子和 = 左孩子的左叶子值（若有） + 左子树左叶子和 + 右子树左叶子和 return leftValue + rightValue; }}; 222.完全二叉树的节点个数力扣: https://leetcode.cn/problems/count-complete-tree-nodes 递归1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。3.确定单层递归的逻辑：先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。代码如下: 123456789class Solution {public: int countNodes(TreeNode* root) { if(root==NULL) return 0; int left=countNodes(root-&gt;left); int right=countNodes(root-&gt;right); return left+right+1; }};","link":"/2025/10/06/hello-world/"},{"title":"","text":"","link":"/2025/10/06/Linux/"},{"title":"Leetcode学习","text":"欢迎来到我的cpp代码学习网站 学习内容参考见 “代码随想录” https://programmercarl.com/ 一、数据结构与算法哈希表常见三种结构 数组 set map在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可重复 能否改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(log n) O(log n) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值（或key）是否可重复 能否更改数值（或key） 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(log n) O(log n) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 STL容器和容器适配器一些基本语法表格1：非STL容器（STL容器适配器） 具体容器 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 栈（stack） push(val)：仅从「栈顶」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「栈顶」元素（无返回值，需用top()获取栈顶值后再删） ❌ 不支持push_back/pop_back；仅支持栈顶操作（LIFO），无迭代器访问 队列（queue） push(val)：仅从「队尾」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「队首」元素（无返回值，需用front()获取队首值后再删） ❌ 不支持push_back/pop_front；仅支持队尾插、队首删（FIFO），无迭代器访问 优先级队列（priority_queue） push(val)：插入元素后自动按优先级排序（底层用vector+堆实现，对外统一用push） pop()：仅删除「优先级最高的元素」（堆顶，无返回值，需用top()获取后再删） ❌ 不支持push_back/pop_back；无顺序概念，仅按优先级操作，无迭代器访问 表格2：STL容器（含关联/非关联区分） 具体容器 STL容器类型（关联/非关联） 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 动态数组（vector） 非关联（序列容器） 1. push_back(val)：从「尾部」插入（唯一的push类接口，无push_front）2. insert(iter, val)：在指定迭代器位置插入 1. pop_back()：删除「尾部」元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间元素 ❌ 不支持push_front（头部插入效率极低）；仅尾部支持push_back/pop_back，指定位置用insert/erase 双向队列（deque） 非关联（序列容器） 1. push_back(val)：从「队尾」插入2. push_front(val)：从「队首」插入 1. pop_back()：删除「队尾」元素2. pop_front()：删除「队首」元素3. erase(iter)：删除指定迭代器位置元素 ✅ 同时支持push_back/push_front（区别于vector）；可随机访问（用[]下标），适合两端频繁操作 集合（set） 关联（有序唯一集合） insert(val)：按红黑树排序插入（无push/push_back，因按「键」有序存储，非位置存储） 1. erase(key)：按元素值删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 完全不支持push/push_back；元素有序且唯一，按值操作而非位置 多重集合（multiset） 关联（有序可重复集合） insert(val)：按红黑树排序插入（无push/push_back，支持重复值插入） 1. erase(key)：删除所有等于key的元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；元素有序可重复，按值删除时需注意是否删除所有匹配项 映射（map） 关联（有序唯一键值对） 1. insert(pair&lt;key, val&gt;)：按key排序插入2. map[key] = val：直接赋值（不存在则插入，存在则修改） 1. erase(key)：按key删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；存储键值对（key唯一），[]操作符可插入/修改值 多重映射（multimap） 关联（有序可重复键值对） insert(pair&lt;key, val&gt;)：按key排序插入（支持重复key插入，无[]操作符） 1. erase(key)：删除所有key匹配的键值对2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back、无[]操作符；key可重复，需用find()/equal_range()获取指定key的元素 所有STL算法（包括sort, reverse等）都严格遵循左闭右开区间的约定，例如反转中没有对下标 i 对应的数值进行反转操作 1reverse(s.begin() , s.begin() + i); 二叉树基础知识 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。 刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。 123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; 深度优先遍历o 前序遍历（递归法，迭代法）o中序遍历（递归法，迭代法）o后序遍历（递归法，迭代法） 广度优先遍历o层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 下面给出前序遍历C++代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 下面是层序遍历C++代码： 12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; }};","link":"/2025/10/03/Data%20Structure%20and%20Algorithms/"}],"tags":[],"categories":[],"pages":[]}