{"posts":[{"title":"Leetcode学习","text":"欢迎来到我的cpp代码学习网站 学习内容参考见 “代码随想录” https://programmercarl.com/ 一、数据结构与算法哈希表常见三种结构 数组 set map在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 集合 底层实现 是否有序 数值是否可重复 能否改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(log n) O(log n) std::unordered_set 哈希表 无序 否 否 O(1) O(1) std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 映射 底层实现 是否有序 数值（或key）是否可重复 能否更改数值（或key） 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(log n) O(log n) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 STL容器和容器适配器一些基本语法表格1：非STL容器（STL容器适配器） 具体容器 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 栈（stack） push(val)：仅从「栈顶」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「栈顶」元素（无返回值，需用top()获取栈顶值后再删） ❌ 不支持push_back/pop_back；仅支持栈顶操作（LIFO），无迭代器访问 队列（queue） push(val)：仅从「队尾」插入（底层默认用deque实现，隐藏push_back，对外统一用push） pop()：仅删除「队首」元素（无返回值，需用front()获取队首值后再删） ❌ 不支持push_back/pop_front；仅支持队尾插、队首删（FIFO），无迭代器访问 优先级队列（priority_queue） push(val)：插入元素后自动按优先级排序（底层用vector+堆实现，对外统一用push） pop()：仅删除「优先级最高的元素」（堆顶，无返回值，需用top()获取后再删） ❌ 不支持push_back/pop_back；无顺序概念，仅按优先级操作，无迭代器访问 表格2：STL容器（含关联/非关联区分） 具体容器 STL容器类型（关联/非关联） 插入操作（函数+说明） 删除操作（函数+说明） 核心语法区别（易混点提醒） 动态数组（vector） 非关联（序列容器） 1. push_back(val)：从「尾部」插入（唯一的push类接口，无push_front）2. insert(iter, val)：在指定迭代器位置插入 1. pop_back()：删除「尾部」元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间元素 ❌ 不支持push_front（头部插入效率极低）；仅尾部支持push_back/pop_back，指定位置用insert/erase 双向队列（deque） 非关联（序列容器） 1. push_back(val)：从「队尾」插入2. push_front(val)：从「队首」插入 1. pop_back()：删除「队尾」元素2. pop_front()：删除「队首」元素3. erase(iter)：删除指定迭代器位置元素 ✅ 同时支持push_back/push_front（区别于vector）；可随机访问（用[]下标），适合两端频繁操作 集合（set） 关联（有序唯一集合） insert(val)：按红黑树排序插入（无push/push_back，因按「键」有序存储，非位置存储） 1. erase(key)：按元素值删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 完全不支持push/push_back；元素有序且唯一，按值操作而非位置 多重集合（multiset） 关联（有序可重复集合） insert(val)：按红黑树排序插入（无push/push_back，支持重复值插入） 1. erase(key)：删除所有等于key的元素2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；元素有序可重复，按值删除时需注意是否删除所有匹配项 映射（map） 关联（有序唯一键值对） 1. insert(pair&lt;key, val&gt;)：按key排序插入2. map[key] = val：直接赋值（不存在则插入，存在则修改） 1. erase(key)：按key删除2. erase(iter)：按迭代器删除3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back；存储键值对（key唯一），[]操作符可插入/修改值 多重映射（multimap） 关联（有序可重复键值对） insert(pair&lt;key, val&gt;)：按key排序插入（支持重复key插入，无[]操作符） 1. erase(key)：删除所有key匹配的键值对2. erase(iter)：删除指定迭代器位置元素3. erase(iter1, iter2)：删除区间 ❌ 不支持push/push_back、无[]操作符；key可重复，需用find()/equal_range()获取指定key的元素 所有STL算法（包括sort, reverse等）都严格遵循左闭右开区间的约定，例如反转中没有对下标 i 对应的数值进行反转操作 1reverse(s.begin() , s.begin() + i); 二叉树基础知识 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。 刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。 123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; 深度优先遍历o 前序遍历（递归法，迭代法）o中序遍历（递归法，迭代法）o后序遍历（递归法，迭代法） 广度优先遍历o层次遍历（迭代法） 在深度优先遍历中：有三个顺序，前中后序遍历，这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 下面给出前序遍历C++代码： 1234567891011121314class Solution {public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; }}; 下面是层序遍历C++代码： 12345678910111213141516171819202122class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; }}; 110.平衡二叉树力扣链接：https://leetcode.cn/problems/balanced-binary-tree 平衡二叉树定义：一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。 注意二叉树高度和深度的区别 递归三步曲分析：1.明确递归函数的参数和返回值参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。2.明确终止条件递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为03.明确单层递归的逻辑如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。代码如下： 1234567891011121314class Solution {public: int getheight(TreeNode* node){ if(node==NULL) return 0; int leftheight=getheight(node-&gt;left); if(leftheight==-1) return -1; int rightheight=getheight(node-&gt;right); if(rightheight==-1) return -1; return abs(leftheight-rightheight)&gt;1?-1:max(leftheight,rightheight)+1; } bool isBalanced(TreeNode* root) { return getheight(root)!=-1?true:false; }}; 257.二叉树的所有路径力扣链接：https://leetcode.cn/problems/binary-tree-paths 递归1.递归函数参数以及返回值要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值。 1void traversal(TreeNode* node, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) 2.考虑递归终止条件找到叶子节点代表一条路径结束, 123if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { 终止处理逻辑} 为什么没有判断cur是否为空呢，因为上面的逻辑可以控制空节点不入循环。接下来再来看一下终止处理的逻辑。这里我们先使用vector结构的path容器来记录路径，最终转化成字符串存入题目要求的结果容器中，代码如下： 12345678910if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { // 遇到叶子节点 string sPath; for (int i = 0; i &lt; path.size() - 1; i++) { // 将path里记录的路径转为string格式 sPath += to_string(path[i]); sPath += &quot;-&gt;&quot;; } sPath += to_string(path[path.size() - 1]); // 记录最后一个节点（叶子节点） result.push_back(sPath); // 收集一个路径 return;} 3.确定单层递归逻辑在走完一条路径后回溯到上一个节点，回溯和递归是一一对应的，有一个递归，就要有一个回溯都在花括号里面。 12345678if (node-&gt;left) { traversal(cur-&gt;left, path, result); path.pop_back(); // 回溯}if (node-&gt;right) { traversal(cur-&gt;right, path, result); path.pop_back(); // 回溯} 最终代码如下: 12345678910111213141516171819202122232425262728293031class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; path,vector&lt;string&gt;&amp; result){ path.push_back(node-&gt;val); if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) { string spath; for(int i=0;i&lt;path.size()-1;i++){ spath+=to_string(path[i]); spath+=&quot;-&gt;&quot;; } spath+=to_string(path[path.size()-1]); result.push_back(spath); return; } if(node-&gt;left!=NULL){ traversal(node-&gt;left,path,result); path.pop_back(); } if(node-&gt;right!=NULL){ traversal(node-&gt;right,path,result); path.pop_back(); } } vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;int&gt; path; vector&lt;string&gt; result; if(root==NULL) return result; traversal(root,path,result); return result; }}; 这个题不太好理解，可以多巩固下。 404.左叶子之和力扣题目链接：https://leetcode.cn/problems/sum-of-left-leaves 递归：递归的遍历顺序为后序遍历（左右中） 1.确定递归函数的参数和返回值判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int2.确定终止条件如果遍历到空节点，那么左叶子值一定是03.确定单层递归的逻辑当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。代码如下: 1234567891011121314151617181920class Solution {public: int sumOfLeftLeaves(TreeNode* root) { if (root == NULL) return 0; // 单层逻辑 int leftValue = 0; // 检查当前节点的左孩子是否是左叶子 if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { leftValue = root-&gt;left-&gt;val; // 是左叶子，记录值 } else { leftValue = sumOfLeftLeaves(root-&gt;left); // 不是，递归求左子树的左叶子和 } // 递归求右子树的左叶子和（右子树的左叶子也是当前树的左叶子） int rightValue = sumOfLeftLeaves(root-&gt;right); // 当前树的左叶子和 = 左孩子的左叶子值（若有） + 左子树左叶子和 + 右子树左叶子和 return leftValue + rightValue; }}; 222.完全二叉树的节点个数力扣: https://leetcode.cn/problems/count-complete-tree-nodes 递归1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。2.确定终止条件：如果为空节点的话，就返回0，表示节点数为0。3.确定单层递归的逻辑：先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。代码如下: 123456789class Solution {public: int countNodes(TreeNode* root) { if(root==NULL) return 0; int left=countNodes(root-&gt;left); int right=countNodes(root-&gt;right); return left+right+1; }}; 513.找树左下角的值力扣：https://leetcode.cn/problems/find-bottom-left-tree-value个人用的层序遍历，可以考虑递归算法求解。 1234567891011121314151617181920212223class Solution {public: int findBottomLeftValue(TreeNode* root) { queue&lt;TreeNode*&gt; que; if(root==NULL) return 0; que.push(root); TreeNode* cur; vector&lt;vector&lt;int&gt;&gt; vec1; while(!que.empty()){ int size=que.size(); vector&lt;int&gt; vec2; for(int i=0;i&lt;size;i++){ cur=que.front(); vec2.push_back(cur-&gt;val); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); } vec1.push_back(vec2); } return vec1[vec1.size()-1][0]; }}; 112.113. 路径总和力扣：https://leetcode.cn/problems/path-sum力扣：https://leetcode.cn/problems/path-sum-ii用257的思想用递归回溯找到所有路径，然后稍加修改就可以求出112，113。112代码如下： 123456789101112131415161718192021222324252627class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; path,int target,int&amp; flag){ path.push_back(node-&gt;val); if(node-&gt;left==NULL&amp;&amp;node-&gt;right==NULL){ if(accumulate(path.begin(),path.end(),0)==target){ flag=1; } return; } if(node-&gt;left){ traversal(node-&gt;left,path,target,flag); path.pop_back(); } if(node-&gt;right){ traversal(node-&gt;right,path,target,flag); path.pop_back(); } } bool hasPathSum(TreeNode* root, int targetSum) { if(root==NULL) return false; vector&lt;int&gt; p; int flag=0; traversal(root,p,targetSum,flag); return flag==1?true:false; }}; 113代码如下: 12345678910111213141516171819202122232425262728class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; path,int target, vector&lt;vector&lt;int&gt;&gt;&amp; result){ path.push_back(node-&gt;val); if(node-&gt;left==NULL&amp;&amp;node-&gt;right==NULL){ if(accumulate(path.begin(),path.end(),0)==target){ result.push_back(path); } return; } if(node-&gt;left){ traversal(node-&gt;left,path,target,result); path.pop_back(); } if(node-&gt;right){ traversal(node-&gt;right,path,target,result); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) { if(root==NULL) return {}; vector&lt;int&gt; p; vector&lt;vector&lt;int&gt;&gt; result; traversal(root,p,targetSum,result); return result; }}; 105. 从前序与中序遍历序列构造二叉树https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal 106. 从中序与后序遍历序列构造二叉树https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal思路其实都一样，通过前序或者后序遍历先找到根节点，先创建一颗只有根节点的树，利用找到根节点的值去中序遍历将其拆分成左右两个树的中序遍历，接着利用中序遍历左右两个子树的节点数量大小来拆分前序和后序的vector容器，分成左子树或者右子树的前序或者后序遍历。最后利用递归分别去递归树的每一个节点完成树的构建。105代码如下： 12345678910111213141516171819202122class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { if(preorder.size()==0||inorder.size()==0) return NULL; int rootval=preorder[0]; TreeNode* root=new TreeNode(rootval); int i; for(i=0;i&lt;inorder.size();i++){ if(inorder[i]==rootval) break; } vector&lt;int&gt; leftinorder(inorder.begin(),inorder.begin()+i); vector&lt;int&gt; rightinorder(inorder.begin()+i+1,inorder.end()); preorder.erase(preorder.begin()); vector&lt;int&gt; leftpreorder(preorder.begin(),preorder.begin()+leftinorder.size()); vector&lt;int&gt; rightpreorder(preorder.begin()+leftinorder.size(),preorder.end()); root-&gt;left=buildTree(leftpreorder,leftinorder); root-&gt;right=buildTree(rightpreorder,rightinorder); return root; }}; 106代码如下： 1234567891011121314151617181920212223class Solution {public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { if(inorder.size()==0||postorder.size()==0) return NULL; int rootval=postorder[postorder.size()-1]; TreeNode* root=new TreeNode(rootval); int i; for(i=0;i&lt;inorder.size();i++){ if(inorder[i]==rootval) break; } vector&lt;int&gt; leftinorder(inorder.begin(),inorder.begin()+i); vector&lt;int&gt; rightinorder(inorder.begin()+i+1,inorder.end()); postorder.pop_back(); vector&lt;int&gt; leftpostorder(postorder.begin(),postorder.begin()+leftinorder.size()); vector&lt;int&gt; rightpostorder(postorder.begin()+leftinorder.size(),postorder.end()); root-&gt;left=buildTree(leftinorder,leftpostorder); root-&gt;right=buildTree(rightinorder,rightpostorder); return root; }}; 654.最大二叉树https://leetcode.cn/problems/maximum-binary-tree本题和105，106思路很像，都是递归方法，递归传入的元素就是左右子树，学会如何分割容器内元素。代码如下： 12345678910111213141516171819202122class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return NULL; int root=INT_MIN; int d; for(int i=0;i&lt;nums.size();i++){ if(nums[i]&gt;root){ root=nums[i]; d=i; } } TreeNode* node=new TreeNode(root); vector&lt;int&gt; left={nums.begin(),nums.begin()+d}; vector&lt;int&gt; right={nums.begin()+d+1,nums.end()}; node-&gt;left=constructMaximumBinaryTree(left); node-&gt;right=constructMaximumBinaryTree(right); return node; }}; 617.合并二叉树https://leetcode.cn/problems/merge-two-binary-trees首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。 反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。单层递归的逻辑就比较好写了，这里我们重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。 那么单层递归中，就要把两棵树的元素加到一起。接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。最终t1就是合并之后的根节点。代码如下： 123456789101112131415class Solution {public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(root1==NULL) return root2; if(root2==NULL) return root1; root1-&gt;val+=root2-&gt;val; root1-&gt;left=mergeTrees(root1-&gt;left,root2-&gt;left); root1-&gt;right=mergeTrees(root1-&gt;right,root2-&gt;right); return root1; }}; 700.二叉搜索树中的搜索给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。https://leetcode.cn/problems/search-in-a-binary-search-tree二叉搜索树是一个有序树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 注意写递归函数的时候会习惯直接写 searchBST(root-&gt;left, val)，却忘了 递归函数还有返回值。递归函数的返回值是什么? 是左子树如果搜索到了val，要将该节点返回。 如果不用一个变量将其接住，那么返回值不就没了。所以要 result = searchBST(root-&gt;left, val)。代码如下： 123456789101112131415class Solution {public: TreeNode* searchBST(TreeNode* root, int val) { if(root==NULL) return NULL; if(root-&gt;val==val) return root; TreeNode* result=NULL; if(root-&gt;val&gt;val){ result=searchBST(root-&gt;left,val); } if(root-&gt;val&lt;val){ result=searchBST(root-&gt;right,val); } return result; }}; 98.验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。https://leetcode.cn/problems/validate-binary-search-tree 易错点：不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。所以要用一个数组存放二叉树中序遍历的元素，数组的数值会从小往大递增，而不是简单的if判断相邻左右子节点的大小。代码如下： 12345678910111213141516171819class Solution {public: vector&lt;int&gt; tree; void traversal(TreeNode* node){ if(node==NULL) return; traversal(node-&gt;left); tree.push_back(node-&gt;val); traversal(node-&gt;right); } bool isValidBST(TreeNode* root) { if(root==NULL) return true; traversal(root); for(int i=1;i&lt;tree.size();i++){ if(tree[i]&lt;=tree[i-1]) return false; } return true; }}; 530.二叉搜索树的最小绝对差给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。https://leetcode.cn/problems/minimum-absolute-difference-in-bst/ 思路注意是二叉搜索树，二叉搜索树可是有序的。遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。代码如下： 12345678910111213141516171819202122class Solution {public: void traversal(TreeNode* node,vector&lt;int&gt;&amp; vec){ if(node==NULL) return; traversal(node-&gt;left,vec); vec.push_back(node-&gt;val); traversal(node-&gt;right,vec); return; } int getMinimumDifference(TreeNode* root) { if(root==NULL) return 0; vector&lt;int&gt; result; traversal(root,result); int d=INT_MAX; for(int i=1;i&lt;result.size();i++){ if(d&gt;result[i]-result[i-1]){ d= result[i]-result[i-1]; } } return d; }}; 501.二叉搜索树中的众数https://leetcode.cn/problems/find-mode-in-binary-search-tree/给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。本题有两种思路，先介绍一种普遍思路，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。代码如下： 123456789101112131415161718192021222324252627282930class Solution {public: void traversal(TreeNode*node,unordered_map&lt;int,int&gt;&amp; m){ if(node==NULL) return; traversal(node-&gt;left,m); m[node-&gt;val]++; traversal(node-&gt;right,m); return; } vector&lt;int&gt; findMode(TreeNode* root) { if(root==NULL) return {}; unordered_map&lt;int,int&gt; m; traversal(root,m); vector&lt;int&gt; result; int maxCount=0; // 先找到最大频率 for (auto&amp; pair : m) { if (pair.second &gt; maxCount) { maxCount = pair.second; } } // 再收集所有频率等于最大频率的元素 for (auto&amp; pair : m) { if (pair.second == maxCount) { result.push_back(pair.first); } } return result; }}; 给出一些代码语法解释： 1for (auto&amp; pair : m) 对于unordered_map来说，它的每个元素是一个「键值对（key-value pair）」，类型为std::pair&lt;const Key, Value&gt;（比如unordered_map&lt;int, int&gt;的元素类型是pair&lt;const int, int&gt;）。因此auto会自动推导出pair的类型为std::pair&lt;const int, int&gt;。这里的&amp;表示「引用」，作用是直接引用容器中的元素，而不是复制元素。 如果不加&amp;（即for (auto pair : m)）：每次循环会创建一个pair的副本（复制容器中的元素到pair）。对于简单类型（如int），复制成本低；但对于复杂类型（如map的键值对pair，尤其是当键或值是大型对象时），复制会产生额外的内存开销和性能损耗。 加&amp;（即for (auto&amp; pair : m)）：pair是容器中元素的引用，直接指向容器中的原始元素，不会产生复制。这能提高遍历效率，尤其是对于大型容器或复杂元素类型。 123for (元素声明 : 容器) { // 循环体（使用声明的元素）} 其中，元素声明 用于定义一个变量接收容器中的元素（通常用 auto 自动推导类型），容器 可以是 STL 容器（如 vector、set、map）、数组等。 接下来考虑第二种思路，因为题目是二叉搜索树，它中序遍历就是有序的。遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int count=0; int maxcount=0; TreeNode*pre=nullptr; void traversal(TreeNode*node,vector&lt;int&gt;&amp; vec){ if(node==NULL) return; traversal(node-&gt;left,vec); if(pre==nullptr) { count=1; } else if(pre-&gt;val==node-&gt;val){ count++; } else{ count=1; } pre=node; if(count&gt;maxcount){ maxcount=count; vec.clear(); vec.push_back(node-&gt;val); } else if(count==maxcount){ vec.push_back(node-&gt;val); } traversal(node-&gt;right,vec); return; } vector&lt;int&gt; findMode(TreeNode* root) { if(root==NULL) return {}; vector&lt;int&gt; result; traversal(root,result); return result; }}; 236. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/本题有难度，递归思路不好想。 递归三部曲 确定递归函数返回值以及参数需要找到节点p，q同时函数返回值应该是一个节点。 1TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 确定终止条件当root是p或q时：说明在当前路径上找到了目标节点，返回该节点（告知上层 “这里有一个目标节点”）。当root是NULL时：说明当前子树中没有p和q，返回NULL（告知上层 “这里没找到”）。终止条件的核心是：遇到目标节点或空节点时，停止深入，返回当前节点作为 “结果信号” 1if (root == q || root == p || root == NULL) return root; 确定单层递归的逻辑对于当前节点root，需要做三件事：1.递归左子树：获取左子树的 “有效祖先节点”（left）；2.递归右子树：获取右子树的 “有效祖先节点”（right）；3.根据left和right判断当前节点 12345if (left == NULL &amp;&amp; right != NULL) return right;else if (left != NULL &amp;&amp; right == NULL) return left;else { // (left == NULL &amp;&amp; right == NULL) return NULL;} 整体代码如下: 123456789101112class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root==q||root==p||root==NULL) return root; TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q); TreeNode* right=lowestCommonAncestor(root-&gt;right,p,q); if(left!=NULL&amp;&amp;right!=NULL) return root; else if(left==NULL&amp;&amp;right!=NULL) return right; else if(left!=NULL&amp;&amp;right==NULL) return left; else return NULL; }}; 算法通过后序遍历的自底向上特性，确保 “先遇到深层节点，再遇到高层节点”。一旦在某个节点满足 “左右子树各含一个目标节点”，就会立即返回该节点。","link":"/2025/10/03/Data%20Structure%20and%20Algorithms/"}],"tags":[],"categories":[],"pages":[]}